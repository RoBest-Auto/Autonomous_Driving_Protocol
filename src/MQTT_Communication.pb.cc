// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MQTT_Communication.proto

#include "MQTT_Communication.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace dispatch {
PROTOBUF_CONSTEXPR Time::Time(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sec_)*/0
  , /*decltype(_impl_.nsec_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TimeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimeDefaultTypeInternal() {}
  union {
    Time _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimeDefaultTypeInternal _Time_default_instance_;
PROTOBUF_CONSTEXPR Header::Header(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.frame_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.stamp_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeaderDefaultTypeInternal() {}
  union {
    Header _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeaderDefaultTypeInternal _Header_default_instance_;
PROTOBUF_CONSTEXPR Point::Point(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointDefaultTypeInternal() {}
  union {
    Point _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointDefaultTypeInternal _Point_default_instance_;
PROTOBUF_CONSTEXPR Quaternion::Quaternion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.w_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QuaternionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuaternionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuaternionDefaultTypeInternal() {}
  union {
    Quaternion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuaternionDefaultTypeInternal _Quaternion_default_instance_;
PROTOBUF_CONSTEXPR Pose::Pose(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.orientation_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PoseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PoseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PoseDefaultTypeInternal() {}
  union {
    Pose _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PoseDefaultTypeInternal _Pose_default_instance_;
PROTOBUF_CONSTEXPR PoseStamped::PoseStamped(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.pose_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PoseStampedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PoseStampedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PoseStampedDefaultTypeInternal() {}
  union {
    PoseStamped _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PoseStampedDefaultTypeInternal _PoseStamped_default_instance_;
PROTOBUF_CONSTEXPR Path::Path(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pose_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PathDefaultTypeInternal() {}
  union {
    Path _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PathDefaultTypeInternal _Path_default_instance_;
PROTOBUF_CONSTEXPR Vector3::Vector3(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Vector3DefaultTypeInternal {
  PROTOBUF_CONSTEXPR Vector3DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Vector3DefaultTypeInternal() {}
  union {
    Vector3 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Vector3DefaultTypeInternal _Vector3_default_instance_;
PROTOBUF_CONSTEXPR Twist::Twist(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.linear_)*/nullptr
  , /*decltype(_impl_.angular_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TwistDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TwistDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TwistDefaultTypeInternal() {}
  union {
    Twist _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TwistDefaultTypeInternal _Twist_default_instance_;
PROTOBUF_CONSTEXPR Current_pose::Current_pose(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pose_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Current_poseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Current_poseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Current_poseDefaultTypeInternal() {}
  union {
    Current_pose _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Current_poseDefaultTypeInternal _Current_pose_default_instance_;
PROTOBUF_CONSTEXPR Current_twist::Current_twist(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.twist_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Current_twistDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Current_twistDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Current_twistDefaultTypeInternal() {}
  union {
    Current_twist _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Current_twistDefaultTypeInternal _Current_twist_default_instance_;
PROTOBUF_CONSTEXPR Goal_pose::Goal_pose(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pose_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Goal_poseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Goal_poseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Goal_poseDefaultTypeInternal() {}
  union {
    Goal_pose _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Goal_poseDefaultTypeInternal _Goal_pose_default_instance_;
PROTOBUF_CONSTEXPR Current_path::Current_path(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pose_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Current_pathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Current_pathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Current_pathDefaultTypeInternal() {}
  union {
    Current_path _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Current_pathDefaultTypeInternal _Current_path_default_instance_;
PROTOBUF_CONSTEXPR Goal_twist::Goal_twist(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.twist_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Goal_twistDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Goal_twistDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Goal_twistDefaultTypeInternal() {}
  union {
    Goal_twist _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Goal_twistDefaultTypeInternal _Goal_twist_default_instance_;
PROTOBUF_CONSTEXPR Multiple_goal::Multiple_goal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pose_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Multiple_goalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Multiple_goalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Multiple_goalDefaultTypeInternal() {}
  union {
    Multiple_goal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Multiple_goalDefaultTypeInternal _Multiple_goal_default_instance_;
PROTOBUF_CONSTEXPR MsgHeader::MsgHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.timestamp_)*/uint64_t{0u}
  , /*decltype(_impl_.msg_id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MsgHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MsgHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MsgHeaderDefaultTypeInternal() {}
  union {
    MsgHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MsgHeaderDefaultTypeInternal _MsgHeader_default_instance_;
PROTOBUF_CONSTEXPR VehicleInfo::VehicleInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.pose_)*/nullptr
  , /*decltype(_impl_.twist_)*/nullptr
  , /*decltype(_impl_.motion_)*/0
  , /*decltype(_impl_.driving_mode_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VehicleInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VehicleInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VehicleInfoDefaultTypeInternal() {}
  union {
    VehicleInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VehicleInfoDefaultTypeInternal _VehicleInfo_default_instance_;
PROTOBUF_CONSTEXPR ActionRequest::ActionRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.path_)*/nullptr
  , /*decltype(_impl_.goal_)*/nullptr
  , /*decltype(_impl_.action_type_)*/0
  , /*decltype(_impl_.park_id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ActionRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActionRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActionRequestDefaultTypeInternal() {}
  union {
    ActionRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionRequestDefaultTypeInternal _ActionRequest_default_instance_;
PROTOBUF_CONSTEXPR ActionResponse::ActionResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.error_msg_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_code_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ActionResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActionResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActionResponseDefaultTypeInternal() {}
  union {
    ActionResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionResponseDefaultTypeInternal _ActionResponse_default_instance_;
PROTOBUF_CONSTEXPR TaskRequest::TaskRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.task_type_)*/0
  , /*decltype(_impl_.area_id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TaskRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TaskRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TaskRequestDefaultTypeInternal() {}
  union {
    TaskRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TaskRequestDefaultTypeInternal _TaskRequest_default_instance_;
PROTOBUF_CONSTEXPR EmergencyBrake::EmergencyBrake(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.valid_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EmergencyBrakeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmergencyBrakeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmergencyBrakeDefaultTypeInternal() {}
  union {
    EmergencyBrake _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmergencyBrakeDefaultTypeInternal _EmergencyBrake_default_instance_;
PROTOBUF_CONSTEXPR Heartbeat::Heartbeat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HeartbeatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeartbeatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeartbeatDefaultTypeInternal() {}
  union {
    Heartbeat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
PROTOBUF_CONSTEXPR HeartbeatACK::HeartbeatACK(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HeartbeatACKDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeartbeatACKDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeartbeatACKDefaultTypeInternal() {}
  union {
    HeartbeatACK _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeartbeatACKDefaultTypeInternal _HeartbeatACK_default_instance_;
PROTOBUF_CONSTEXPR FaultInformation::FaultInformation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.fault_str_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.fault_code_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FaultInformationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FaultInformationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FaultInformationDefaultTypeInternal() {}
  union {
    FaultInformation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FaultInformationDefaultTypeInternal _FaultInformation_default_instance_;
}  // namespace dispatch
static ::_pb::Metadata file_level_metadata_MQTT_5fCommunication_2eproto[24];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_MQTT_5fCommunication_2eproto[6];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_MQTT_5fCommunication_2eproto = nullptr;

const uint32_t TableStruct_MQTT_5fCommunication_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::Time, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::Time, _impl_.sec_),
  PROTOBUF_FIELD_OFFSET(::dispatch::Time, _impl_.nsec_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::Header, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::Header, _impl_.stamp_),
  PROTOBUF_FIELD_OFFSET(::dispatch::Header, _impl_.frame_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::Point, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::Point, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::dispatch::Point, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::dispatch::Point, _impl_.z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::Quaternion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::Quaternion, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::dispatch::Quaternion, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::dispatch::Quaternion, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::dispatch::Quaternion, _impl_.w_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::Pose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::Pose, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::dispatch::Pose, _impl_.orientation_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::PoseStamped, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::PoseStamped, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::dispatch::PoseStamped, _impl_.pose_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::Path, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::Path, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::dispatch::Path, _impl_.pose_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::Vector3, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::Vector3, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::dispatch::Vector3, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::dispatch::Vector3, _impl_.z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::Twist, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::Twist, _impl_.linear_),
  PROTOBUF_FIELD_OFFSET(::dispatch::Twist, _impl_.angular_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::Current_pose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::Current_pose, _impl_.pose_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::Current_twist, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::Current_twist, _impl_.twist_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::Goal_pose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::Goal_pose, _impl_.pose_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::Current_path, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::Current_path, _impl_.pose_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::Goal_twist, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::Goal_twist, _impl_.twist_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::Multiple_goal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::Multiple_goal, _impl_.pose_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::MsgHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::MsgHeader, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::dispatch::MsgHeader, _impl_.msg_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::VehicleInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::VehicleInfo, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::dispatch::VehicleInfo, _impl_.pose_),
  PROTOBUF_FIELD_OFFSET(::dispatch::VehicleInfo, _impl_.twist_),
  PROTOBUF_FIELD_OFFSET(::dispatch::VehicleInfo, _impl_.motion_),
  PROTOBUF_FIELD_OFFSET(::dispatch::VehicleInfo, _impl_.driving_mode_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::ActionRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::ActionRequest, _impl_.action_type_),
  PROTOBUF_FIELD_OFFSET(::dispatch::ActionRequest, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::dispatch::ActionRequest, _impl_.goal_),
  PROTOBUF_FIELD_OFFSET(::dispatch::ActionRequest, _impl_.park_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::ActionResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::ActionResponse, _impl_.error_code_),
  PROTOBUF_FIELD_OFFSET(::dispatch::ActionResponse, _impl_.error_msg_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::TaskRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::TaskRequest, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::dispatch::TaskRequest, _impl_.task_type_),
  PROTOBUF_FIELD_OFFSET(::dispatch::TaskRequest, _impl_.area_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::EmergencyBrake, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::EmergencyBrake, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::dispatch::EmergencyBrake, _impl_.valid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::Heartbeat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::Heartbeat, _impl_.header_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::HeartbeatACK, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::HeartbeatACK, _impl_.header_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dispatch::FaultInformation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dispatch::FaultInformation, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::dispatch::FaultInformation, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::dispatch::FaultInformation, _impl_.fault_code_),
  PROTOBUF_FIELD_OFFSET(::dispatch::FaultInformation, _impl_.fault_str_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::dispatch::Time)},
  { 8, -1, -1, sizeof(::dispatch::Header)},
  { 16, -1, -1, sizeof(::dispatch::Point)},
  { 25, -1, -1, sizeof(::dispatch::Quaternion)},
  { 35, -1, -1, sizeof(::dispatch::Pose)},
  { 43, -1, -1, sizeof(::dispatch::PoseStamped)},
  { 51, -1, -1, sizeof(::dispatch::Path)},
  { 59, -1, -1, sizeof(::dispatch::Vector3)},
  { 68, -1, -1, sizeof(::dispatch::Twist)},
  { 76, -1, -1, sizeof(::dispatch::Current_pose)},
  { 83, -1, -1, sizeof(::dispatch::Current_twist)},
  { 90, -1, -1, sizeof(::dispatch::Goal_pose)},
  { 97, -1, -1, sizeof(::dispatch::Current_path)},
  { 104, -1, -1, sizeof(::dispatch::Goal_twist)},
  { 111, -1, -1, sizeof(::dispatch::Multiple_goal)},
  { 118, -1, -1, sizeof(::dispatch::MsgHeader)},
  { 126, -1, -1, sizeof(::dispatch::VehicleInfo)},
  { 137, -1, -1, sizeof(::dispatch::ActionRequest)},
  { 147, -1, -1, sizeof(::dispatch::ActionResponse)},
  { 155, -1, -1, sizeof(::dispatch::TaskRequest)},
  { 164, -1, -1, sizeof(::dispatch::EmergencyBrake)},
  { 172, -1, -1, sizeof(::dispatch::Heartbeat)},
  { 179, -1, -1, sizeof(::dispatch::HeartbeatACK)},
  { 186, -1, -1, sizeof(::dispatch::FaultInformation)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::dispatch::_Time_default_instance_._instance,
  &::dispatch::_Header_default_instance_._instance,
  &::dispatch::_Point_default_instance_._instance,
  &::dispatch::_Quaternion_default_instance_._instance,
  &::dispatch::_Pose_default_instance_._instance,
  &::dispatch::_PoseStamped_default_instance_._instance,
  &::dispatch::_Path_default_instance_._instance,
  &::dispatch::_Vector3_default_instance_._instance,
  &::dispatch::_Twist_default_instance_._instance,
  &::dispatch::_Current_pose_default_instance_._instance,
  &::dispatch::_Current_twist_default_instance_._instance,
  &::dispatch::_Goal_pose_default_instance_._instance,
  &::dispatch::_Current_path_default_instance_._instance,
  &::dispatch::_Goal_twist_default_instance_._instance,
  &::dispatch::_Multiple_goal_default_instance_._instance,
  &::dispatch::_MsgHeader_default_instance_._instance,
  &::dispatch::_VehicleInfo_default_instance_._instance,
  &::dispatch::_ActionRequest_default_instance_._instance,
  &::dispatch::_ActionResponse_default_instance_._instance,
  &::dispatch::_TaskRequest_default_instance_._instance,
  &::dispatch::_EmergencyBrake_default_instance_._instance,
  &::dispatch::_Heartbeat_default_instance_._instance,
  &::dispatch::_HeartbeatACK_default_instance_._instance,
  &::dispatch::_FaultInformation_default_instance_._instance,
};

const char descriptor_table_protodef_MQTT_5fCommunication_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030MQTT_Communication.proto\022\010dispatch\"!\n\004"
  "Time\022\013\n\003sec\030\001 \001(\005\022\014\n\004nsec\030\002 \001(\005\"9\n\006Heade"
  "r\022\035\n\005stamp\030\001 \001(\0132\016.dispatch.Time\022\020\n\010fram"
  "e_id\030\002 \001(\t\"(\n\005Point\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001("
  "\001\022\t\n\001z\030\003 \001(\001\"8\n\nQuaternion\022\t\n\001x\030\001 \001(\001\022\t\n"
  "\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\022\t\n\001w\030\004 \001(\001\"T\n\004Pose\022!"
  "\n\010position\030\001 \001(\0132\017.dispatch.Point\022)\n\013ori"
  "entation\030\002 \001(\0132\024.dispatch.Quaternion\"M\n\013"
  "PoseStamped\022 \n\006header\030\001 \001(\0132\020.dispatch.H"
  "eader\022\034\n\004pose\030\002 \001(\0132\016.dispatch.Pose\"M\n\004P"
  "ath\022 \n\006header\030\001 \001(\0132\020.dispatch.Header\022#\n"
  "\004pose\030\002 \003(\0132\025.dispatch.PoseStamped\"*\n\007Ve"
  "ctor3\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\"N"
  "\n\005Twist\022!\n\006linear\030\001 \001(\0132\021.dispatch.Vecto"
  "r3\022\"\n\007angular\030\002 \001(\0132\021.dispatch.Vector3\","
  "\n\014Current_pose\022\034\n\004pose\030\001 \001(\0132\016.dispatch."
  "Pose\"/\n\rCurrent_twist\022\036\n\005twist\030\001 \001(\0132\017.d"
  "ispatch.Twist\")\n\tGoal_pose\022\034\n\004pose\030\001 \001(\013"
  "2\016.dispatch.Pose\",\n\014Current_path\022\034\n\004pose"
  "\030\001 \003(\0132\016.dispatch.Pose\",\n\nGoal_twist\022\036\n\005"
  "twist\030\001 \001(\0132\017.dispatch.Twist\"4\n\rMultiple"
  "_goal\022#\n\004pose\030\001 \003(\0132\025.dispatch.PoseStamp"
  "ed\".\n\tMsgHeader\022\021\n\ttimestamp\030\001 \001(\004\022\016\n\006ms"
  "g_id\030\002 \001(\r\"\313\001\n\013VehicleInfo\022#\n\006header\030\001 \001"
  "(\0132\023.dispatch.MsgHeader\022\034\n\004pose\030\002 \001(\0132\016."
  "dispatch.Pose\022\036\n\005twist\030\003 \001(\0132\017.dispatch."
  "Twist\022,\n\006motion\030\004 \001(\0162\034.dispatch.Vehicle"
  "MotionState\022+\n\014driving_mode\030\005 \001(\0162\025.disp"
  "atch.DrivingMode\"\224\001\n\rActionRequest\022)\n\013ac"
  "tion_type\030\001 \001(\0162\024.dispatch.ActionType\022$\n"
  "\004path\030\002 \001(\0132\026.dispatch.Current_path\022!\n\004g"
  "oal\030\003 \001(\0132\023.dispatch.Goal_pose\022\017\n\007park_i"
  "d\030\004 \001(\r\"7\n\016ActionResponse\022\022\n\nerror_code\030"
  "\001 \001(\005\022\021\n\terror_msg\030\002 \001(\t\"j\n\013TaskRequest\022"
  "#\n\006header\030\001 \001(\0132\023.dispatch.MsgHeader\022%\n\t"
  "task_type\030\002 \001(\0162\022.dispatch.TaskType\022\017\n\007a"
  "rea_id\030\003 \001(\r\"D\n\016EmergencyBrake\022#\n\006header"
  "\030\001 \001(\0132\023.dispatch.MsgHeader\022\r\n\005valid\030\002 \001"
  "(\010\"0\n\tHeartbeat\022#\n\006header\030\001 \001(\0132\023.dispat"
  "ch.MsgHeader\"3\n\014HeartbeatACK\022#\n\006header\030\001"
  " \001(\0132\023.dispatch.MsgHeader\"\201\001\n\020FaultInfor"
  "mation\022#\n\006header\030\001 \001(\0132\023.dispatch.MsgHea"
  "der\022!\n\004type\030\002 \001(\0162\023.dispatch.FaultType\022\022"
  "\n\nfault_code\030\003 \001(\r\022\021\n\tfault_str\030\004 \001(\t*2\n"
  "\nActionType\022\r\n\tGoForward\020\000\022\010\n\004Stop\020\001\022\013\n\007"
  "Parking\020\002*(\n\010TaskType\022\014\n\010LoadUnit\020\000\022\016\n\nU"
  "nloadUnit\020\001*\230\001\n\017VehicleJobState\022\013\n\007Offli"
  "ne\020\000\022\010\n\004Idle\020\001\022\022\n\016EmptyTransport\020\002\022\022\n\016He"
  "avyTransport\020\003\022\017\n\013WaitingLoad\020\004\022\017\n\013Loadi"
  "ngUnit\020\005\022\021\n\rWaitingUnload\020\006\022\021\n\rUnloading"
  "Unit\020\007*V\n\013DrivingMode\022\024\n\020LocalDrivingMod"
  "e\020\000\022\023\n\017TelecontrolMode\020\001\022\016\n\nRemoteMode\020\002"
  "\022\014\n\010AutoMode\020\003*b\n\022VehicleMotionState\022\023\n\017"
  "StationaryState\020\000\022\020\n\014ForwardState\020\001\022\r\n\tB"
  "ackState\020\002\022\026\n\022UnknownMotionState\020\003*\213\001\n\tF"
  "aultType\022\020\n\014VehicleFault\020\000\022\032\n\026Autonomous"
  "DrivingFault\020\001\022\026\n\022RemoteDrivingFault\020\002\022\034"
  "\n\030CommunicationSystemFault\020\003\022\032\n\026Localiza"
  "ionSystemFault\020\004b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_MQTT_5fCommunication_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_MQTT_5fCommunication_2eproto = {
    false, false, 2344, descriptor_table_protodef_MQTT_5fCommunication_2eproto,
    "MQTT_Communication.proto",
    &descriptor_table_MQTT_5fCommunication_2eproto_once, nullptr, 0, 24,
    schemas, file_default_instances, TableStruct_MQTT_5fCommunication_2eproto::offsets,
    file_level_metadata_MQTT_5fCommunication_2eproto, file_level_enum_descriptors_MQTT_5fCommunication_2eproto,
    file_level_service_descriptors_MQTT_5fCommunication_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_MQTT_5fCommunication_2eproto_getter() {
  return &descriptor_table_MQTT_5fCommunication_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_MQTT_5fCommunication_2eproto(&descriptor_table_MQTT_5fCommunication_2eproto);
namespace dispatch {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MQTT_5fCommunication_2eproto);
  return file_level_enum_descriptors_MQTT_5fCommunication_2eproto[0];
}
bool ActionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MQTT_5fCommunication_2eproto);
  return file_level_enum_descriptors_MQTT_5fCommunication_2eproto[1];
}
bool TaskType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehicleJobState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MQTT_5fCommunication_2eproto);
  return file_level_enum_descriptors_MQTT_5fCommunication_2eproto[2];
}
bool VehicleJobState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DrivingMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MQTT_5fCommunication_2eproto);
  return file_level_enum_descriptors_MQTT_5fCommunication_2eproto[3];
}
bool DrivingMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehicleMotionState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MQTT_5fCommunication_2eproto);
  return file_level_enum_descriptors_MQTT_5fCommunication_2eproto[4];
}
bool VehicleMotionState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FaultType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MQTT_5fCommunication_2eproto);
  return file_level_enum_descriptors_MQTT_5fCommunication_2eproto[5];
}
bool FaultType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Time::_Internal {
 public:
};

Time::Time(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.Time)
}
Time::Time(const Time& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Time* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sec_){}
    , decltype(_impl_.nsec_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.sec_, &from._impl_.sec_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nsec_) -
    reinterpret_cast<char*>(&_impl_.sec_)) + sizeof(_impl_.nsec_));
  // @@protoc_insertion_point(copy_constructor:dispatch.Time)
}

inline void Time::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sec_){0}
    , decltype(_impl_.nsec_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Time::~Time() {
  // @@protoc_insertion_point(destructor:dispatch.Time)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Time::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Time::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Time::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.Time)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.sec_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.nsec_) -
      reinterpret_cast<char*>(&_impl_.sec_)) + sizeof(_impl_.nsec_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Time::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 sec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 nsec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.nsec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Time::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.Time)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 sec = 1;
  if (this->_internal_sec() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_sec(), target);
  }

  // int32 nsec = 2;
  if (this->_internal_nsec() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nsec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.Time)
  return target;
}

size_t Time::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.Time)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 sec = 1;
  if (this->_internal_sec() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sec());
  }

  // int32 nsec = 2;
  if (this->_internal_nsec() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nsec());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Time::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Time::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Time::GetClassData() const { return &_class_data_; }


void Time::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Time*>(&to_msg);
  auto& from = static_cast<const Time&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.Time)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_sec() != 0) {
    _this->_internal_set_sec(from._internal_sec());
  }
  if (from._internal_nsec() != 0) {
    _this->_internal_set_nsec(from._internal_nsec());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Time::CopyFrom(const Time& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.Time)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Time::IsInitialized() const {
  return true;
}

void Time::InternalSwap(Time* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Time, _impl_.nsec_)
      + sizeof(Time::_impl_.nsec_)
      - PROTOBUF_FIELD_OFFSET(Time, _impl_.sec_)>(
          reinterpret_cast<char*>(&_impl_.sec_),
          reinterpret_cast<char*>(&other->_impl_.sec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Time::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[0]);
}

// ===================================================================

class Header::_Internal {
 public:
  static const ::dispatch::Time& stamp(const Header* msg);
};

const ::dispatch::Time&
Header::_Internal::stamp(const Header* msg) {
  return *msg->_impl_.stamp_;
}
Header::Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.Header)
}
Header::Header(const Header& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Header* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.frame_id_){}
    , decltype(_impl_.stamp_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.frame_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.frame_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_frame_id().empty()) {
    _this->_impl_.frame_id_.Set(from._internal_frame_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_stamp()) {
    _this->_impl_.stamp_ = new ::dispatch::Time(*from._impl_.stamp_);
  }
  // @@protoc_insertion_point(copy_constructor:dispatch.Header)
}

inline void Header::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.frame_id_){}
    , decltype(_impl_.stamp_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.frame_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.frame_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Header::~Header() {
  // @@protoc_insertion_point(destructor:dispatch.Header)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Header::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.frame_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.stamp_;
}

void Header::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Header::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.Header)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.frame_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.stamp_ != nullptr) {
    delete _impl_.stamp_;
  }
  _impl_.stamp_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Header::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.Time stamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string frame_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_frame_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "dispatch.Header.frame_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Header::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.Header)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.Time stamp = 1;
  if (this->_internal_has_stamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stamp(this),
        _Internal::stamp(this).GetCachedSize(), target, stream);
  }

  // string frame_id = 2;
  if (!this->_internal_frame_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_frame_id().data(), static_cast<int>(this->_internal_frame_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "dispatch.Header.frame_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_frame_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.Header)
  return target;
}

size_t Header::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.Header)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string frame_id = 2;
  if (!this->_internal_frame_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_frame_id());
  }

  // .dispatch.Time stamp = 1;
  if (this->_internal_has_stamp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stamp_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Header::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Header::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Header::GetClassData() const { return &_class_data_; }


void Header::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Header*>(&to_msg);
  auto& from = static_cast<const Header&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.Header)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_frame_id().empty()) {
    _this->_internal_set_frame_id(from._internal_frame_id());
  }
  if (from._internal_has_stamp()) {
    _this->_internal_mutable_stamp()->::dispatch::Time::MergeFrom(
        from._internal_stamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Header::CopyFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Header::IsInitialized() const {
  return true;
}

void Header::InternalSwap(Header* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.frame_id_, lhs_arena,
      &other->_impl_.frame_id_, rhs_arena
  );
  swap(_impl_.stamp_, other->_impl_.stamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Header::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[1]);
}

// ===================================================================

class Point::_Internal {
 public:
};

Point::Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.Point)
}
Point::Point(const Point& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Point* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:dispatch.Point)
}

inline void Point::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Point::~Point() {
  // @@protoc_insertion_point(destructor:dispatch.Point)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Point::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Point::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Point::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.Point)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Point::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Point::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.Point)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.Point)
  return target;
}

size_t Point::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.Point)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Point::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Point::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Point::GetClassData() const { return &_class_data_; }


void Point::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Point*>(&to_msg);
  auto& from = static_cast<const Point&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.Point)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Point::CopyFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point::IsInitialized() const {
  return true;
}

void Point::InternalSwap(Point* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Point, _impl_.z_)
      + sizeof(Point::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(Point, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Point::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[2]);
}

// ===================================================================

class Quaternion::_Internal {
 public:
};

Quaternion::Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.Quaternion)
}
Quaternion::Quaternion(const Quaternion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Quaternion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.w_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.w_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  // @@protoc_insertion_point(copy_constructor:dispatch.Quaternion)
}

inline void Quaternion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.w_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:dispatch.Quaternion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Quaternion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Quaternion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.Quaternion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.w_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Quaternion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double w = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Quaternion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.Quaternion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  // double w = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_w = this->_internal_w();
  uint64_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_w(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.Quaternion)
  return target;
}

size_t Quaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.Quaternion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  // double w = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_w = this->_internal_w();
  uint64_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Quaternion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Quaternion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Quaternion::GetClassData() const { return &_class_data_; }


void Quaternion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Quaternion*>(&to_msg);
  auto& from = static_cast<const Quaternion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.Quaternion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_w = from._internal_w();
  uint64_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    _this->_internal_set_w(from._internal_w());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Quaternion::CopyFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quaternion::IsInitialized() const {
  return true;
}

void Quaternion::InternalSwap(Quaternion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.w_)
      + sizeof(Quaternion::_impl_.w_)
      - PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Quaternion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[3]);
}

// ===================================================================

class Pose::_Internal {
 public:
  static const ::dispatch::Point& position(const Pose* msg);
  static const ::dispatch::Quaternion& orientation(const Pose* msg);
};

const ::dispatch::Point&
Pose::_Internal::position(const Pose* msg) {
  return *msg->_impl_.position_;
}
const ::dispatch::Quaternion&
Pose::_Internal::orientation(const Pose* msg) {
  return *msg->_impl_.orientation_;
}
Pose::Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.Pose)
}
Pose::Pose(const Pose& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Pose* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.position_){nullptr}
    , decltype(_impl_.orientation_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::dispatch::Point(*from._impl_.position_);
  }
  if (from._internal_has_orientation()) {
    _this->_impl_.orientation_ = new ::dispatch::Quaternion(*from._impl_.orientation_);
  }
  // @@protoc_insertion_point(copy_constructor:dispatch.Pose)
}

inline void Pose::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.position_){nullptr}
    , decltype(_impl_.orientation_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Pose::~Pose() {
  // @@protoc_insertion_point(destructor:dispatch.Pose)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Pose::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.orientation_;
}

void Pose::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Pose::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.Pose)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.orientation_ != nullptr) {
    delete _impl_.orientation_;
  }
  _impl_.orientation_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Pose::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.Point position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .dispatch.Quaternion orientation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_orientation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Pose::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.Pose)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.Point position = 1;
  if (this->_internal_has_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .dispatch.Quaternion orientation = 2;
  if (this->_internal_has_orientation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::orientation(this),
        _Internal::orientation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.Pose)
  return target;
}

size_t Pose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.Pose)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dispatch.Point position = 1;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // .dispatch.Quaternion orientation = 2;
  if (this->_internal_has_orientation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.orientation_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Pose::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Pose::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Pose::GetClassData() const { return &_class_data_; }


void Pose::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Pose*>(&to_msg);
  auto& from = static_cast<const Pose&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.Pose)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_position()) {
    _this->_internal_mutable_position()->::dispatch::Point::MergeFrom(
        from._internal_position());
  }
  if (from._internal_has_orientation()) {
    _this->_internal_mutable_orientation()->::dispatch::Quaternion::MergeFrom(
        from._internal_orientation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Pose::CopyFrom(const Pose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pose::IsInitialized() const {
  return true;
}

void Pose::InternalSwap(Pose* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Pose, _impl_.orientation_)
      + sizeof(Pose::_impl_.orientation_)
      - PROTOBUF_FIELD_OFFSET(Pose, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Pose::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[4]);
}

// ===================================================================

class PoseStamped::_Internal {
 public:
  static const ::dispatch::Header& header(const PoseStamped* msg);
  static const ::dispatch::Pose& pose(const PoseStamped* msg);
};

const ::dispatch::Header&
PoseStamped::_Internal::header(const PoseStamped* msg) {
  return *msg->_impl_.header_;
}
const ::dispatch::Pose&
PoseStamped::_Internal::pose(const PoseStamped* msg) {
  return *msg->_impl_.pose_;
}
PoseStamped::PoseStamped(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.PoseStamped)
}
PoseStamped::PoseStamped(const PoseStamped& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PoseStamped* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.pose_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::dispatch::Header(*from._impl_.header_);
  }
  if (from._internal_has_pose()) {
    _this->_impl_.pose_ = new ::dispatch::Pose(*from._impl_.pose_);
  }
  // @@protoc_insertion_point(copy_constructor:dispatch.PoseStamped)
}

inline void PoseStamped::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.pose_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PoseStamped::~PoseStamped() {
  // @@protoc_insertion_point(destructor:dispatch.PoseStamped)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PoseStamped::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.pose_;
}

void PoseStamped::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PoseStamped::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.PoseStamped)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr) {
    delete _impl_.pose_;
  }
  _impl_.pose_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PoseStamped::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.Header header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .dispatch.Pose pose = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pose(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PoseStamped::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.PoseStamped)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.Header header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .dispatch.Pose pose = 2;
  if (this->_internal_has_pose()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::pose(this),
        _Internal::pose(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.PoseStamped)
  return target;
}

size_t PoseStamped::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.PoseStamped)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dispatch.Header header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .dispatch.Pose pose = 2;
  if (this->_internal_has_pose()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pose_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PoseStamped::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PoseStamped::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PoseStamped::GetClassData() const { return &_class_data_; }


void PoseStamped::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PoseStamped*>(&to_msg);
  auto& from = static_cast<const PoseStamped&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.PoseStamped)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::dispatch::Header::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_pose()) {
    _this->_internal_mutable_pose()->::dispatch::Pose::MergeFrom(
        from._internal_pose());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PoseStamped::CopyFrom(const PoseStamped& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.PoseStamped)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PoseStamped::IsInitialized() const {
  return true;
}

void PoseStamped::InternalSwap(PoseStamped* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PoseStamped, _impl_.pose_)
      + sizeof(PoseStamped::_impl_.pose_)
      - PROTOBUF_FIELD_OFFSET(PoseStamped, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PoseStamped::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[5]);
}

// ===================================================================

class Path::_Internal {
 public:
  static const ::dispatch::Header& header(const Path* msg);
};

const ::dispatch::Header&
Path::_Internal::header(const Path* msg) {
  return *msg->_impl_.header_;
}
Path::Path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.Path)
}
Path::Path(const Path& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Path* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pose_){from._impl_.pose_}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::dispatch::Header(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:dispatch.Path)
}

inline void Path::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pose_){arena}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Path::~Path() {
  // @@protoc_insertion_point(destructor:dispatch.Path)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Path::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pose_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void Path::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Path::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.Path)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pose_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Path::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.Header header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .dispatch.PoseStamped pose = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pose(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Path::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.Path)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.Header header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .dispatch.PoseStamped pose = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pose_size()); i < n; i++) {
    const auto& repfield = this->_internal_pose(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.Path)
  return target;
}

size_t Path::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.Path)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .dispatch.PoseStamped pose = 2;
  total_size += 1UL * this->_internal_pose_size();
  for (const auto& msg : this->_impl_.pose_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .dispatch.Header header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Path::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Path::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Path::GetClassData() const { return &_class_data_; }


void Path::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Path*>(&to_msg);
  auto& from = static_cast<const Path&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.Path)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.pose_.MergeFrom(from._impl_.pose_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::dispatch::Header::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Path::CopyFrom(const Path& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.Path)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Path::IsInitialized() const {
  return true;
}

void Path::InternalSwap(Path* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.pose_.InternalSwap(&other->_impl_.pose_);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Path::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[6]);
}

// ===================================================================

class Vector3::_Internal {
 public:
};

Vector3::Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.Vector3)
}
Vector3::Vector3(const Vector3& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Vector3* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:dispatch.Vector3)
}

inline void Vector3::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Vector3::~Vector3() {
  // @@protoc_insertion_point(destructor:dispatch.Vector3)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vector3::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Vector3::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vector3::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.Vector3)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vector3::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vector3::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.Vector3)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.Vector3)
  return target;
}

size_t Vector3::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.Vector3)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vector3::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vector3::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vector3::GetClassData() const { return &_class_data_; }


void Vector3::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vector3*>(&to_msg);
  auto& from = static_cast<const Vector3&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.Vector3)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vector3::CopyFrom(const Vector3& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.Vector3)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector3::IsInitialized() const {
  return true;
}

void Vector3::InternalSwap(Vector3* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vector3, _impl_.z_)
      + sizeof(Vector3::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(Vector3, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vector3::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[7]);
}

// ===================================================================

class Twist::_Internal {
 public:
  static const ::dispatch::Vector3& linear(const Twist* msg);
  static const ::dispatch::Vector3& angular(const Twist* msg);
};

const ::dispatch::Vector3&
Twist::_Internal::linear(const Twist* msg) {
  return *msg->_impl_.linear_;
}
const ::dispatch::Vector3&
Twist::_Internal::angular(const Twist* msg) {
  return *msg->_impl_.angular_;
}
Twist::Twist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.Twist)
}
Twist::Twist(const Twist& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Twist* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.linear_){nullptr}
    , decltype(_impl_.angular_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_linear()) {
    _this->_impl_.linear_ = new ::dispatch::Vector3(*from._impl_.linear_);
  }
  if (from._internal_has_angular()) {
    _this->_impl_.angular_ = new ::dispatch::Vector3(*from._impl_.angular_);
  }
  // @@protoc_insertion_point(copy_constructor:dispatch.Twist)
}

inline void Twist::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.linear_){nullptr}
    , decltype(_impl_.angular_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Twist::~Twist() {
  // @@protoc_insertion_point(destructor:dispatch.Twist)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Twist::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.linear_;
  if (this != internal_default_instance()) delete _impl_.angular_;
}

void Twist::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Twist::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.Twist)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.linear_ != nullptr) {
    delete _impl_.linear_;
  }
  _impl_.linear_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.angular_ != nullptr) {
    delete _impl_.angular_;
  }
  _impl_.angular_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Twist::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.Vector3 linear = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_linear(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .dispatch.Vector3 angular = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_angular(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Twist::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.Twist)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.Vector3 linear = 1;
  if (this->_internal_has_linear()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::linear(this),
        _Internal::linear(this).GetCachedSize(), target, stream);
  }

  // .dispatch.Vector3 angular = 2;
  if (this->_internal_has_angular()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::angular(this),
        _Internal::angular(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.Twist)
  return target;
}

size_t Twist::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.Twist)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dispatch.Vector3 linear = 1;
  if (this->_internal_has_linear()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.linear_);
  }

  // .dispatch.Vector3 angular = 2;
  if (this->_internal_has_angular()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.angular_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Twist::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Twist::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Twist::GetClassData() const { return &_class_data_; }


void Twist::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Twist*>(&to_msg);
  auto& from = static_cast<const Twist&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.Twist)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_linear()) {
    _this->_internal_mutable_linear()->::dispatch::Vector3::MergeFrom(
        from._internal_linear());
  }
  if (from._internal_has_angular()) {
    _this->_internal_mutable_angular()->::dispatch::Vector3::MergeFrom(
        from._internal_angular());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Twist::CopyFrom(const Twist& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.Twist)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Twist::IsInitialized() const {
  return true;
}

void Twist::InternalSwap(Twist* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Twist, _impl_.angular_)
      + sizeof(Twist::_impl_.angular_)
      - PROTOBUF_FIELD_OFFSET(Twist, _impl_.linear_)>(
          reinterpret_cast<char*>(&_impl_.linear_),
          reinterpret_cast<char*>(&other->_impl_.linear_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Twist::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[8]);
}

// ===================================================================

class Current_pose::_Internal {
 public:
  static const ::dispatch::Pose& pose(const Current_pose* msg);
};

const ::dispatch::Pose&
Current_pose::_Internal::pose(const Current_pose* msg) {
  return *msg->_impl_.pose_;
}
Current_pose::Current_pose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.Current_pose)
}
Current_pose::Current_pose(const Current_pose& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Current_pose* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pose_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pose()) {
    _this->_impl_.pose_ = new ::dispatch::Pose(*from._impl_.pose_);
  }
  // @@protoc_insertion_point(copy_constructor:dispatch.Current_pose)
}

inline void Current_pose::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pose_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Current_pose::~Current_pose() {
  // @@protoc_insertion_point(destructor:dispatch.Current_pose)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Current_pose::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pose_;
}

void Current_pose::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Current_pose::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.Current_pose)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr) {
    delete _impl_.pose_;
  }
  _impl_.pose_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Current_pose::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.Pose pose = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pose(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Current_pose::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.Current_pose)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.Pose pose = 1;
  if (this->_internal_has_pose()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pose(this),
        _Internal::pose(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.Current_pose)
  return target;
}

size_t Current_pose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.Current_pose)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dispatch.Pose pose = 1;
  if (this->_internal_has_pose()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pose_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Current_pose::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Current_pose::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Current_pose::GetClassData() const { return &_class_data_; }


void Current_pose::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Current_pose*>(&to_msg);
  auto& from = static_cast<const Current_pose&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.Current_pose)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pose()) {
    _this->_internal_mutable_pose()->::dispatch::Pose::MergeFrom(
        from._internal_pose());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Current_pose::CopyFrom(const Current_pose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.Current_pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Current_pose::IsInitialized() const {
  return true;
}

void Current_pose::InternalSwap(Current_pose* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.pose_, other->_impl_.pose_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Current_pose::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[9]);
}

// ===================================================================

class Current_twist::_Internal {
 public:
  static const ::dispatch::Twist& twist(const Current_twist* msg);
};

const ::dispatch::Twist&
Current_twist::_Internal::twist(const Current_twist* msg) {
  return *msg->_impl_.twist_;
}
Current_twist::Current_twist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.Current_twist)
}
Current_twist::Current_twist(const Current_twist& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Current_twist* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.twist_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_twist()) {
    _this->_impl_.twist_ = new ::dispatch::Twist(*from._impl_.twist_);
  }
  // @@protoc_insertion_point(copy_constructor:dispatch.Current_twist)
}

inline void Current_twist::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.twist_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Current_twist::~Current_twist() {
  // @@protoc_insertion_point(destructor:dispatch.Current_twist)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Current_twist::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.twist_;
}

void Current_twist::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Current_twist::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.Current_twist)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.twist_ != nullptr) {
    delete _impl_.twist_;
  }
  _impl_.twist_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Current_twist::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.Twist twist = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_twist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Current_twist::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.Current_twist)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.Twist twist = 1;
  if (this->_internal_has_twist()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::twist(this),
        _Internal::twist(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.Current_twist)
  return target;
}

size_t Current_twist::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.Current_twist)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dispatch.Twist twist = 1;
  if (this->_internal_has_twist()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.twist_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Current_twist::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Current_twist::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Current_twist::GetClassData() const { return &_class_data_; }


void Current_twist::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Current_twist*>(&to_msg);
  auto& from = static_cast<const Current_twist&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.Current_twist)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_twist()) {
    _this->_internal_mutable_twist()->::dispatch::Twist::MergeFrom(
        from._internal_twist());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Current_twist::CopyFrom(const Current_twist& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.Current_twist)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Current_twist::IsInitialized() const {
  return true;
}

void Current_twist::InternalSwap(Current_twist* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.twist_, other->_impl_.twist_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Current_twist::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[10]);
}

// ===================================================================

class Goal_pose::_Internal {
 public:
  static const ::dispatch::Pose& pose(const Goal_pose* msg);
};

const ::dispatch::Pose&
Goal_pose::_Internal::pose(const Goal_pose* msg) {
  return *msg->_impl_.pose_;
}
Goal_pose::Goal_pose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.Goal_pose)
}
Goal_pose::Goal_pose(const Goal_pose& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Goal_pose* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pose_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pose()) {
    _this->_impl_.pose_ = new ::dispatch::Pose(*from._impl_.pose_);
  }
  // @@protoc_insertion_point(copy_constructor:dispatch.Goal_pose)
}

inline void Goal_pose::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pose_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Goal_pose::~Goal_pose() {
  // @@protoc_insertion_point(destructor:dispatch.Goal_pose)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Goal_pose::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pose_;
}

void Goal_pose::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Goal_pose::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.Goal_pose)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr) {
    delete _impl_.pose_;
  }
  _impl_.pose_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Goal_pose::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.Pose pose = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pose(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Goal_pose::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.Goal_pose)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.Pose pose = 1;
  if (this->_internal_has_pose()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pose(this),
        _Internal::pose(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.Goal_pose)
  return target;
}

size_t Goal_pose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.Goal_pose)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dispatch.Pose pose = 1;
  if (this->_internal_has_pose()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pose_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Goal_pose::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Goal_pose::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Goal_pose::GetClassData() const { return &_class_data_; }


void Goal_pose::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Goal_pose*>(&to_msg);
  auto& from = static_cast<const Goal_pose&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.Goal_pose)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pose()) {
    _this->_internal_mutable_pose()->::dispatch::Pose::MergeFrom(
        from._internal_pose());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Goal_pose::CopyFrom(const Goal_pose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.Goal_pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Goal_pose::IsInitialized() const {
  return true;
}

void Goal_pose::InternalSwap(Goal_pose* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.pose_, other->_impl_.pose_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Goal_pose::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[11]);
}

// ===================================================================

class Current_path::_Internal {
 public:
};

Current_path::Current_path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.Current_path)
}
Current_path::Current_path(const Current_path& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Current_path* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pose_){from._impl_.pose_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:dispatch.Current_path)
}

inline void Current_path::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pose_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Current_path::~Current_path() {
  // @@protoc_insertion_point(destructor:dispatch.Current_path)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Current_path::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pose_.~RepeatedPtrField();
}

void Current_path::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Current_path::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.Current_path)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pose_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Current_path::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .dispatch.Pose pose = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pose(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Current_path::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.Current_path)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .dispatch.Pose pose = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pose_size()); i < n; i++) {
    const auto& repfield = this->_internal_pose(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.Current_path)
  return target;
}

size_t Current_path::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.Current_path)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .dispatch.Pose pose = 1;
  total_size += 1UL * this->_internal_pose_size();
  for (const auto& msg : this->_impl_.pose_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Current_path::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Current_path::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Current_path::GetClassData() const { return &_class_data_; }


void Current_path::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Current_path*>(&to_msg);
  auto& from = static_cast<const Current_path&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.Current_path)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.pose_.MergeFrom(from._impl_.pose_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Current_path::CopyFrom(const Current_path& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.Current_path)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Current_path::IsInitialized() const {
  return true;
}

void Current_path::InternalSwap(Current_path* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.pose_.InternalSwap(&other->_impl_.pose_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Current_path::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[12]);
}

// ===================================================================

class Goal_twist::_Internal {
 public:
  static const ::dispatch::Twist& twist(const Goal_twist* msg);
};

const ::dispatch::Twist&
Goal_twist::_Internal::twist(const Goal_twist* msg) {
  return *msg->_impl_.twist_;
}
Goal_twist::Goal_twist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.Goal_twist)
}
Goal_twist::Goal_twist(const Goal_twist& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Goal_twist* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.twist_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_twist()) {
    _this->_impl_.twist_ = new ::dispatch::Twist(*from._impl_.twist_);
  }
  // @@protoc_insertion_point(copy_constructor:dispatch.Goal_twist)
}

inline void Goal_twist::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.twist_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Goal_twist::~Goal_twist() {
  // @@protoc_insertion_point(destructor:dispatch.Goal_twist)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Goal_twist::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.twist_;
}

void Goal_twist::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Goal_twist::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.Goal_twist)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.twist_ != nullptr) {
    delete _impl_.twist_;
  }
  _impl_.twist_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Goal_twist::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.Twist twist = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_twist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Goal_twist::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.Goal_twist)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.Twist twist = 1;
  if (this->_internal_has_twist()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::twist(this),
        _Internal::twist(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.Goal_twist)
  return target;
}

size_t Goal_twist::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.Goal_twist)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dispatch.Twist twist = 1;
  if (this->_internal_has_twist()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.twist_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Goal_twist::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Goal_twist::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Goal_twist::GetClassData() const { return &_class_data_; }


void Goal_twist::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Goal_twist*>(&to_msg);
  auto& from = static_cast<const Goal_twist&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.Goal_twist)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_twist()) {
    _this->_internal_mutable_twist()->::dispatch::Twist::MergeFrom(
        from._internal_twist());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Goal_twist::CopyFrom(const Goal_twist& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.Goal_twist)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Goal_twist::IsInitialized() const {
  return true;
}

void Goal_twist::InternalSwap(Goal_twist* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.twist_, other->_impl_.twist_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Goal_twist::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[13]);
}

// ===================================================================

class Multiple_goal::_Internal {
 public:
};

Multiple_goal::Multiple_goal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.Multiple_goal)
}
Multiple_goal::Multiple_goal(const Multiple_goal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Multiple_goal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pose_){from._impl_.pose_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:dispatch.Multiple_goal)
}

inline void Multiple_goal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pose_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Multiple_goal::~Multiple_goal() {
  // @@protoc_insertion_point(destructor:dispatch.Multiple_goal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Multiple_goal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pose_.~RepeatedPtrField();
}

void Multiple_goal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Multiple_goal::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.Multiple_goal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pose_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Multiple_goal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .dispatch.PoseStamped pose = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pose(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Multiple_goal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.Multiple_goal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .dispatch.PoseStamped pose = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pose_size()); i < n; i++) {
    const auto& repfield = this->_internal_pose(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.Multiple_goal)
  return target;
}

size_t Multiple_goal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.Multiple_goal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .dispatch.PoseStamped pose = 1;
  total_size += 1UL * this->_internal_pose_size();
  for (const auto& msg : this->_impl_.pose_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Multiple_goal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Multiple_goal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Multiple_goal::GetClassData() const { return &_class_data_; }


void Multiple_goal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Multiple_goal*>(&to_msg);
  auto& from = static_cast<const Multiple_goal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.Multiple_goal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.pose_.MergeFrom(from._impl_.pose_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Multiple_goal::CopyFrom(const Multiple_goal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.Multiple_goal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Multiple_goal::IsInitialized() const {
  return true;
}

void Multiple_goal::InternalSwap(Multiple_goal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.pose_.InternalSwap(&other->_impl_.pose_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Multiple_goal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[14]);
}

// ===================================================================

class MsgHeader::_Internal {
 public:
};

MsgHeader::MsgHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.MsgHeader)
}
MsgHeader::MsgHeader(const MsgHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MsgHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.timestamp_){}
    , decltype(_impl_.msg_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.msg_id_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.msg_id_));
  // @@protoc_insertion_point(copy_constructor:dispatch.MsgHeader)
}

inline void MsgHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.timestamp_){uint64_t{0u}}
    , decltype(_impl_.msg_id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MsgHeader::~MsgHeader() {
  // @@protoc_insertion_point(destructor:dispatch.MsgHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MsgHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MsgHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MsgHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.MsgHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.msg_id_) -
      reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.msg_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MsgHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 msg_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MsgHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.MsgHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 timestamp = 1;
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_timestamp(), target);
  }

  // uint32 msg_id = 2;
  if (this->_internal_msg_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_msg_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.MsgHeader)
  return target;
}

size_t MsgHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.MsgHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 timestamp = 1;
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());
  }

  // uint32 msg_id = 2;
  if (this->_internal_msg_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MsgHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MsgHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MsgHeader::GetClassData() const { return &_class_data_; }


void MsgHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MsgHeader*>(&to_msg);
  auto& from = static_cast<const MsgHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.MsgHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  if (from._internal_msg_id() != 0) {
    _this->_internal_set_msg_id(from._internal_msg_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MsgHeader::CopyFrom(const MsgHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.MsgHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgHeader::IsInitialized() const {
  return true;
}

void MsgHeader::InternalSwap(MsgHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgHeader, _impl_.msg_id_)
      + sizeof(MsgHeader::_impl_.msg_id_)
      - PROTOBUF_FIELD_OFFSET(MsgHeader, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MsgHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[15]);
}

// ===================================================================

class VehicleInfo::_Internal {
 public:
  static const ::dispatch::MsgHeader& header(const VehicleInfo* msg);
  static const ::dispatch::Pose& pose(const VehicleInfo* msg);
  static const ::dispatch::Twist& twist(const VehicleInfo* msg);
};

const ::dispatch::MsgHeader&
VehicleInfo::_Internal::header(const VehicleInfo* msg) {
  return *msg->_impl_.header_;
}
const ::dispatch::Pose&
VehicleInfo::_Internal::pose(const VehicleInfo* msg) {
  return *msg->_impl_.pose_;
}
const ::dispatch::Twist&
VehicleInfo::_Internal::twist(const VehicleInfo* msg) {
  return *msg->_impl_.twist_;
}
VehicleInfo::VehicleInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.VehicleInfo)
}
VehicleInfo::VehicleInfo(const VehicleInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VehicleInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.pose_){nullptr}
    , decltype(_impl_.twist_){nullptr}
    , decltype(_impl_.motion_){}
    , decltype(_impl_.driving_mode_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::dispatch::MsgHeader(*from._impl_.header_);
  }
  if (from._internal_has_pose()) {
    _this->_impl_.pose_ = new ::dispatch::Pose(*from._impl_.pose_);
  }
  if (from._internal_has_twist()) {
    _this->_impl_.twist_ = new ::dispatch::Twist(*from._impl_.twist_);
  }
  ::memcpy(&_impl_.motion_, &from._impl_.motion_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.driving_mode_) -
    reinterpret_cast<char*>(&_impl_.motion_)) + sizeof(_impl_.driving_mode_));
  // @@protoc_insertion_point(copy_constructor:dispatch.VehicleInfo)
}

inline void VehicleInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.pose_){nullptr}
    , decltype(_impl_.twist_){nullptr}
    , decltype(_impl_.motion_){0}
    , decltype(_impl_.driving_mode_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VehicleInfo::~VehicleInfo() {
  // @@protoc_insertion_point(destructor:dispatch.VehicleInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VehicleInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.pose_;
  if (this != internal_default_instance()) delete _impl_.twist_;
}

void VehicleInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VehicleInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.VehicleInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr) {
    delete _impl_.pose_;
  }
  _impl_.pose_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.twist_ != nullptr) {
    delete _impl_.twist_;
  }
  _impl_.twist_ = nullptr;
  ::memset(&_impl_.motion_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.driving_mode_) -
      reinterpret_cast<char*>(&_impl_.motion_)) + sizeof(_impl_.driving_mode_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VehicleInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .dispatch.Pose pose = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pose(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .dispatch.Twist twist = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_twist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .dispatch.VehicleMotionState motion = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_motion(static_cast<::dispatch::VehicleMotionState>(val));
        } else
          goto handle_unusual;
        continue;
      // .dispatch.DrivingMode driving_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_driving_mode(static_cast<::dispatch::DrivingMode>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VehicleInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.VehicleInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.MsgHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .dispatch.Pose pose = 2;
  if (this->_internal_has_pose()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::pose(this),
        _Internal::pose(this).GetCachedSize(), target, stream);
  }

  // .dispatch.Twist twist = 3;
  if (this->_internal_has_twist()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::twist(this),
        _Internal::twist(this).GetCachedSize(), target, stream);
  }

  // .dispatch.VehicleMotionState motion = 4;
  if (this->_internal_motion() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_motion(), target);
  }

  // .dispatch.DrivingMode driving_mode = 5;
  if (this->_internal_driving_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_driving_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.VehicleInfo)
  return target;
}

size_t VehicleInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.VehicleInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dispatch.MsgHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .dispatch.Pose pose = 2;
  if (this->_internal_has_pose()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pose_);
  }

  // .dispatch.Twist twist = 3;
  if (this->_internal_has_twist()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.twist_);
  }

  // .dispatch.VehicleMotionState motion = 4;
  if (this->_internal_motion() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_motion());
  }

  // .dispatch.DrivingMode driving_mode = 5;
  if (this->_internal_driving_mode() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_driving_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VehicleInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VehicleInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VehicleInfo::GetClassData() const { return &_class_data_; }


void VehicleInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VehicleInfo*>(&to_msg);
  auto& from = static_cast<const VehicleInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.VehicleInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::dispatch::MsgHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_pose()) {
    _this->_internal_mutable_pose()->::dispatch::Pose::MergeFrom(
        from._internal_pose());
  }
  if (from._internal_has_twist()) {
    _this->_internal_mutable_twist()->::dispatch::Twist::MergeFrom(
        from._internal_twist());
  }
  if (from._internal_motion() != 0) {
    _this->_internal_set_motion(from._internal_motion());
  }
  if (from._internal_driving_mode() != 0) {
    _this->_internal_set_driving_mode(from._internal_driving_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VehicleInfo::CopyFrom(const VehicleInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.VehicleInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VehicleInfo::IsInitialized() const {
  return true;
}

void VehicleInfo::InternalSwap(VehicleInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VehicleInfo, _impl_.driving_mode_)
      + sizeof(VehicleInfo::_impl_.driving_mode_)
      - PROTOBUF_FIELD_OFFSET(VehicleInfo, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VehicleInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[16]);
}

// ===================================================================

class ActionRequest::_Internal {
 public:
  static const ::dispatch::Current_path& path(const ActionRequest* msg);
  static const ::dispatch::Goal_pose& goal(const ActionRequest* msg);
};

const ::dispatch::Current_path&
ActionRequest::_Internal::path(const ActionRequest* msg) {
  return *msg->_impl_.path_;
}
const ::dispatch::Goal_pose&
ActionRequest::_Internal::goal(const ActionRequest* msg) {
  return *msg->_impl_.goal_;
}
ActionRequest::ActionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.ActionRequest)
}
ActionRequest::ActionRequest(const ActionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ActionRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){nullptr}
    , decltype(_impl_.goal_){nullptr}
    , decltype(_impl_.action_type_){}
    , decltype(_impl_.park_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_path()) {
    _this->_impl_.path_ = new ::dispatch::Current_path(*from._impl_.path_);
  }
  if (from._internal_has_goal()) {
    _this->_impl_.goal_ = new ::dispatch::Goal_pose(*from._impl_.goal_);
  }
  ::memcpy(&_impl_.action_type_, &from._impl_.action_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.park_id_) -
    reinterpret_cast<char*>(&_impl_.action_type_)) + sizeof(_impl_.park_id_));
  // @@protoc_insertion_point(copy_constructor:dispatch.ActionRequest)
}

inline void ActionRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){nullptr}
    , decltype(_impl_.goal_){nullptr}
    , decltype(_impl_.action_type_){0}
    , decltype(_impl_.park_id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ActionRequest::~ActionRequest() {
  // @@protoc_insertion_point(destructor:dispatch.ActionRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActionRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.path_;
  if (this != internal_default_instance()) delete _impl_.goal_;
}

void ActionRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.ActionRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.path_ != nullptr) {
    delete _impl_.path_;
  }
  _impl_.path_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.goal_ != nullptr) {
    delete _impl_.goal_;
  }
  _impl_.goal_ = nullptr;
  ::memset(&_impl_.action_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.park_id_) -
      reinterpret_cast<char*>(&_impl_.action_type_)) + sizeof(_impl_.park_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActionRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.ActionType action_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_action_type(static_cast<::dispatch::ActionType>(val));
        } else
          goto handle_unusual;
        continue;
      // .dispatch.Current_path path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .dispatch.Goal_pose goal = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_goal(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 park_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.park_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActionRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.ActionRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.ActionType action_type = 1;
  if (this->_internal_action_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_action_type(), target);
  }

  // .dispatch.Current_path path = 2;
  if (this->_internal_has_path()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::path(this),
        _Internal::path(this).GetCachedSize(), target, stream);
  }

  // .dispatch.Goal_pose goal = 3;
  if (this->_internal_has_goal()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::goal(this),
        _Internal::goal(this).GetCachedSize(), target, stream);
  }

  // uint32 park_id = 4;
  if (this->_internal_park_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_park_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.ActionRequest)
  return target;
}

size_t ActionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.ActionRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dispatch.Current_path path = 2;
  if (this->_internal_has_path()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.path_);
  }

  // .dispatch.Goal_pose goal = 3;
  if (this->_internal_has_goal()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.goal_);
  }

  // .dispatch.ActionType action_type = 1;
  if (this->_internal_action_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_action_type());
  }

  // uint32 park_id = 4;
  if (this->_internal_park_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_park_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ActionRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ActionRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ActionRequest::GetClassData() const { return &_class_data_; }


void ActionRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ActionRequest*>(&to_msg);
  auto& from = static_cast<const ActionRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.ActionRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_path()) {
    _this->_internal_mutable_path()->::dispatch::Current_path::MergeFrom(
        from._internal_path());
  }
  if (from._internal_has_goal()) {
    _this->_internal_mutable_goal()->::dispatch::Goal_pose::MergeFrom(
        from._internal_goal());
  }
  if (from._internal_action_type() != 0) {
    _this->_internal_set_action_type(from._internal_action_type());
  }
  if (from._internal_park_id() != 0) {
    _this->_internal_set_park_id(from._internal_park_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ActionRequest::CopyFrom(const ActionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.ActionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionRequest::IsInitialized() const {
  return true;
}

void ActionRequest::InternalSwap(ActionRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActionRequest, _impl_.park_id_)
      + sizeof(ActionRequest::_impl_.park_id_)
      - PROTOBUF_FIELD_OFFSET(ActionRequest, _impl_.path_)>(
          reinterpret_cast<char*>(&_impl_.path_),
          reinterpret_cast<char*>(&other->_impl_.path_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ActionRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[17]);
}

// ===================================================================

class ActionResponse::_Internal {
 public:
};

ActionResponse::ActionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.ActionResponse)
}
ActionResponse::ActionResponse(const ActionResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ActionResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.error_msg_){}
    , decltype(_impl_.error_code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_error_msg().empty()) {
    _this->_impl_.error_msg_.Set(from._internal_error_msg(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.error_code_ = from._impl_.error_code_;
  // @@protoc_insertion_point(copy_constructor:dispatch.ActionResponse)
}

inline void ActionResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.error_msg_){}
    , decltype(_impl_.error_code_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.error_msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ActionResponse::~ActionResponse() {
  // @@protoc_insertion_point(destructor:dispatch.ActionResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActionResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_msg_.Destroy();
}

void ActionResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.ActionResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.error_msg_.ClearToEmpty();
  _impl_.error_code_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActionResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 error_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string error_msg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_error_msg();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "dispatch.ActionResponse.error_msg"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActionResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.ActionResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 error_code = 1;
  if (this->_internal_error_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_error_code(), target);
  }

  // string error_msg = 2;
  if (!this->_internal_error_msg().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_error_msg().data(), static_cast<int>(this->_internal_error_msg().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "dispatch.ActionResponse.error_msg");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_error_msg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.ActionResponse)
  return target;
}

size_t ActionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.ActionResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string error_msg = 2;
  if (!this->_internal_error_msg().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error_msg());
  }

  // int32 error_code = 1;
  if (this->_internal_error_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_error_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ActionResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ActionResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ActionResponse::GetClassData() const { return &_class_data_; }


void ActionResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ActionResponse*>(&to_msg);
  auto& from = static_cast<const ActionResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.ActionResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_error_msg().empty()) {
    _this->_internal_set_error_msg(from._internal_error_msg());
  }
  if (from._internal_error_code() != 0) {
    _this->_internal_set_error_code(from._internal_error_code());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ActionResponse::CopyFrom(const ActionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.ActionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionResponse::IsInitialized() const {
  return true;
}

void ActionResponse::InternalSwap(ActionResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_msg_, lhs_arena,
      &other->_impl_.error_msg_, rhs_arena
  );
  swap(_impl_.error_code_, other->_impl_.error_code_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ActionResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[18]);
}

// ===================================================================

class TaskRequest::_Internal {
 public:
  static const ::dispatch::MsgHeader& header(const TaskRequest* msg);
};

const ::dispatch::MsgHeader&
TaskRequest::_Internal::header(const TaskRequest* msg) {
  return *msg->_impl_.header_;
}
TaskRequest::TaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.TaskRequest)
}
TaskRequest::TaskRequest(const TaskRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TaskRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.task_type_){}
    , decltype(_impl_.area_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::dispatch::MsgHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.task_type_, &from._impl_.task_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.area_id_) -
    reinterpret_cast<char*>(&_impl_.task_type_)) + sizeof(_impl_.area_id_));
  // @@protoc_insertion_point(copy_constructor:dispatch.TaskRequest)
}

inline void TaskRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.task_type_){0}
    , decltype(_impl_.area_id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TaskRequest::~TaskRequest() {
  // @@protoc_insertion_point(destructor:dispatch.TaskRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TaskRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void TaskRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TaskRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.TaskRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  ::memset(&_impl_.task_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.area_id_) -
      reinterpret_cast<char*>(&_impl_.task_type_)) + sizeof(_impl_.area_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TaskRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .dispatch.TaskType task_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_task_type(static_cast<::dispatch::TaskType>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 area_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.area_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TaskRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.TaskRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.MsgHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .dispatch.TaskType task_type = 2;
  if (this->_internal_task_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_task_type(), target);
  }

  // uint32 area_id = 3;
  if (this->_internal_area_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_area_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.TaskRequest)
  return target;
}

size_t TaskRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.TaskRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dispatch.MsgHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .dispatch.TaskType task_type = 2;
  if (this->_internal_task_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_task_type());
  }

  // uint32 area_id = 3;
  if (this->_internal_area_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_area_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TaskRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TaskRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TaskRequest::GetClassData() const { return &_class_data_; }


void TaskRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TaskRequest*>(&to_msg);
  auto& from = static_cast<const TaskRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.TaskRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::dispatch::MsgHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_task_type() != 0) {
    _this->_internal_set_task_type(from._internal_task_type());
  }
  if (from._internal_area_id() != 0) {
    _this->_internal_set_area_id(from._internal_area_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TaskRequest::CopyFrom(const TaskRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.TaskRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskRequest::IsInitialized() const {
  return true;
}

void TaskRequest::InternalSwap(TaskRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TaskRequest, _impl_.area_id_)
      + sizeof(TaskRequest::_impl_.area_id_)
      - PROTOBUF_FIELD_OFFSET(TaskRequest, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TaskRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[19]);
}

// ===================================================================

class EmergencyBrake::_Internal {
 public:
  static const ::dispatch::MsgHeader& header(const EmergencyBrake* msg);
};

const ::dispatch::MsgHeader&
EmergencyBrake::_Internal::header(const EmergencyBrake* msg) {
  return *msg->_impl_.header_;
}
EmergencyBrake::EmergencyBrake(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.EmergencyBrake)
}
EmergencyBrake::EmergencyBrake(const EmergencyBrake& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EmergencyBrake* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.valid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::dispatch::MsgHeader(*from._impl_.header_);
  }
  _this->_impl_.valid_ = from._impl_.valid_;
  // @@protoc_insertion_point(copy_constructor:dispatch.EmergencyBrake)
}

inline void EmergencyBrake::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.valid_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EmergencyBrake::~EmergencyBrake() {
  // @@protoc_insertion_point(destructor:dispatch.EmergencyBrake)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EmergencyBrake::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void EmergencyBrake::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EmergencyBrake::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.EmergencyBrake)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _impl_.valid_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EmergencyBrake::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool valid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EmergencyBrake::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.EmergencyBrake)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.MsgHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // bool valid = 2;
  if (this->_internal_valid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_valid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.EmergencyBrake)
  return target;
}

size_t EmergencyBrake::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.EmergencyBrake)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dispatch.MsgHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // bool valid = 2;
  if (this->_internal_valid() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EmergencyBrake::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EmergencyBrake::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EmergencyBrake::GetClassData() const { return &_class_data_; }


void EmergencyBrake::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EmergencyBrake*>(&to_msg);
  auto& from = static_cast<const EmergencyBrake&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.EmergencyBrake)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::dispatch::MsgHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_valid() != 0) {
    _this->_internal_set_valid(from._internal_valid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EmergencyBrake::CopyFrom(const EmergencyBrake& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.EmergencyBrake)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmergencyBrake::IsInitialized() const {
  return true;
}

void EmergencyBrake::InternalSwap(EmergencyBrake* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EmergencyBrake, _impl_.valid_)
      + sizeof(EmergencyBrake::_impl_.valid_)
      - PROTOBUF_FIELD_OFFSET(EmergencyBrake, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EmergencyBrake::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[20]);
}

// ===================================================================

class Heartbeat::_Internal {
 public:
  static const ::dispatch::MsgHeader& header(const Heartbeat* msg);
};

const ::dispatch::MsgHeader&
Heartbeat::_Internal::header(const Heartbeat* msg) {
  return *msg->_impl_.header_;
}
Heartbeat::Heartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.Heartbeat)
}
Heartbeat::Heartbeat(const Heartbeat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Heartbeat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::dispatch::MsgHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:dispatch.Heartbeat)
}

inline void Heartbeat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Heartbeat::~Heartbeat() {
  // @@protoc_insertion_point(destructor:dispatch.Heartbeat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Heartbeat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void Heartbeat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Heartbeat::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.Heartbeat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Heartbeat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Heartbeat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.Heartbeat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.MsgHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.Heartbeat)
  return target;
}

size_t Heartbeat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.Heartbeat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dispatch.MsgHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Heartbeat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Heartbeat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Heartbeat::GetClassData() const { return &_class_data_; }


void Heartbeat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Heartbeat*>(&to_msg);
  auto& from = static_cast<const Heartbeat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.Heartbeat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::dispatch::MsgHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Heartbeat::CopyFrom(const Heartbeat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.Heartbeat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Heartbeat::IsInitialized() const {
  return true;
}

void Heartbeat::InternalSwap(Heartbeat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Heartbeat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[21]);
}

// ===================================================================

class HeartbeatACK::_Internal {
 public:
  static const ::dispatch::MsgHeader& header(const HeartbeatACK* msg);
};

const ::dispatch::MsgHeader&
HeartbeatACK::_Internal::header(const HeartbeatACK* msg) {
  return *msg->_impl_.header_;
}
HeartbeatACK::HeartbeatACK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.HeartbeatACK)
}
HeartbeatACK::HeartbeatACK(const HeartbeatACK& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HeartbeatACK* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::dispatch::MsgHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:dispatch.HeartbeatACK)
}

inline void HeartbeatACK::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HeartbeatACK::~HeartbeatACK() {
  // @@protoc_insertion_point(destructor:dispatch.HeartbeatACK)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HeartbeatACK::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void HeartbeatACK::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HeartbeatACK::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.HeartbeatACK)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HeartbeatACK::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HeartbeatACK::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.HeartbeatACK)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.MsgHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.HeartbeatACK)
  return target;
}

size_t HeartbeatACK::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.HeartbeatACK)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .dispatch.MsgHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeartbeatACK::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HeartbeatACK::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeartbeatACK::GetClassData() const { return &_class_data_; }


void HeartbeatACK::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HeartbeatACK*>(&to_msg);
  auto& from = static_cast<const HeartbeatACK&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.HeartbeatACK)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::dispatch::MsgHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HeartbeatACK::CopyFrom(const HeartbeatACK& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.HeartbeatACK)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatACK::IsInitialized() const {
  return true;
}

void HeartbeatACK::InternalSwap(HeartbeatACK* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HeartbeatACK::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[22]);
}

// ===================================================================

class FaultInformation::_Internal {
 public:
  static const ::dispatch::MsgHeader& header(const FaultInformation* msg);
};

const ::dispatch::MsgHeader&
FaultInformation::_Internal::header(const FaultInformation* msg) {
  return *msg->_impl_.header_;
}
FaultInformation::FaultInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:dispatch.FaultInformation)
}
FaultInformation::FaultInformation(const FaultInformation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FaultInformation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.fault_str_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.fault_code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.fault_str_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fault_str_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fault_str().empty()) {
    _this->_impl_.fault_str_.Set(from._internal_fault_str(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::dispatch::MsgHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fault_code_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.fault_code_));
  // @@protoc_insertion_point(copy_constructor:dispatch.FaultInformation)
}

inline void FaultInformation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.fault_str_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.fault_code_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.fault_str_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fault_str_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FaultInformation::~FaultInformation() {
  // @@protoc_insertion_point(destructor:dispatch.FaultInformation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FaultInformation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fault_str_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void FaultInformation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FaultInformation::Clear() {
// @@protoc_insertion_point(message_clear_start:dispatch.FaultInformation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fault_str_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.fault_code_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.fault_code_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FaultInformation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .dispatch.MsgHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .dispatch.FaultType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::dispatch::FaultType>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 fault_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.fault_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string fault_str = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_fault_str();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "dispatch.FaultInformation.fault_str"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FaultInformation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dispatch.FaultInformation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .dispatch.MsgHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .dispatch.FaultType type = 2;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // uint32 fault_code = 3;
  if (this->_internal_fault_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_fault_code(), target);
  }

  // string fault_str = 4;
  if (!this->_internal_fault_str().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_fault_str().data(), static_cast<int>(this->_internal_fault_str().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "dispatch.FaultInformation.fault_str");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_fault_str(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dispatch.FaultInformation)
  return target;
}

size_t FaultInformation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dispatch.FaultInformation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string fault_str = 4;
  if (!this->_internal_fault_str().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_fault_str());
  }

  // .dispatch.MsgHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .dispatch.FaultType type = 2;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // uint32 fault_code = 3;
  if (this->_internal_fault_code() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fault_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FaultInformation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FaultInformation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FaultInformation::GetClassData() const { return &_class_data_; }


void FaultInformation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FaultInformation*>(&to_msg);
  auto& from = static_cast<const FaultInformation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:dispatch.FaultInformation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_fault_str().empty()) {
    _this->_internal_set_fault_str(from._internal_fault_str());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::dispatch::MsgHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_fault_code() != 0) {
    _this->_internal_set_fault_code(from._internal_fault_code());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FaultInformation::CopyFrom(const FaultInformation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dispatch.FaultInformation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FaultInformation::IsInitialized() const {
  return true;
}

void FaultInformation::InternalSwap(FaultInformation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fault_str_, lhs_arena,
      &other->_impl_.fault_str_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FaultInformation, _impl_.fault_code_)
      + sizeof(FaultInformation::_impl_.fault_code_)
      - PROTOBUF_FIELD_OFFSET(FaultInformation, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FaultInformation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_MQTT_5fCommunication_2eproto_getter, &descriptor_table_MQTT_5fCommunication_2eproto_once,
      file_level_metadata_MQTT_5fCommunication_2eproto[23]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace dispatch
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::dispatch::Time*
Arena::CreateMaybeMessage< ::dispatch::Time >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::Time >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::Header*
Arena::CreateMaybeMessage< ::dispatch::Header >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::Header >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::Point*
Arena::CreateMaybeMessage< ::dispatch::Point >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::Point >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::Quaternion*
Arena::CreateMaybeMessage< ::dispatch::Quaternion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::Quaternion >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::Pose*
Arena::CreateMaybeMessage< ::dispatch::Pose >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::Pose >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::PoseStamped*
Arena::CreateMaybeMessage< ::dispatch::PoseStamped >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::PoseStamped >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::Path*
Arena::CreateMaybeMessage< ::dispatch::Path >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::Path >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::Vector3*
Arena::CreateMaybeMessage< ::dispatch::Vector3 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::Vector3 >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::Twist*
Arena::CreateMaybeMessage< ::dispatch::Twist >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::Twist >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::Current_pose*
Arena::CreateMaybeMessage< ::dispatch::Current_pose >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::Current_pose >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::Current_twist*
Arena::CreateMaybeMessage< ::dispatch::Current_twist >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::Current_twist >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::Goal_pose*
Arena::CreateMaybeMessage< ::dispatch::Goal_pose >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::Goal_pose >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::Current_path*
Arena::CreateMaybeMessage< ::dispatch::Current_path >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::Current_path >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::Goal_twist*
Arena::CreateMaybeMessage< ::dispatch::Goal_twist >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::Goal_twist >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::Multiple_goal*
Arena::CreateMaybeMessage< ::dispatch::Multiple_goal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::Multiple_goal >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::MsgHeader*
Arena::CreateMaybeMessage< ::dispatch::MsgHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::MsgHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::VehicleInfo*
Arena::CreateMaybeMessage< ::dispatch::VehicleInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::VehicleInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::ActionRequest*
Arena::CreateMaybeMessage< ::dispatch::ActionRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::ActionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::ActionResponse*
Arena::CreateMaybeMessage< ::dispatch::ActionResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::ActionResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::TaskRequest*
Arena::CreateMaybeMessage< ::dispatch::TaskRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::TaskRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::EmergencyBrake*
Arena::CreateMaybeMessage< ::dispatch::EmergencyBrake >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::EmergencyBrake >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::Heartbeat*
Arena::CreateMaybeMessage< ::dispatch::Heartbeat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::Heartbeat >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::HeartbeatACK*
Arena::CreateMaybeMessage< ::dispatch::HeartbeatACK >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::HeartbeatACK >(arena);
}
template<> PROTOBUF_NOINLINE ::dispatch::FaultInformation*
Arena::CreateMaybeMessage< ::dispatch::FaultInformation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dispatch::FaultInformation >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
