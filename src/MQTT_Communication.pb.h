// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MQTT_Communication.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MQTT_5fCommunication_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MQTT_5fCommunication_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "MQTT_Communication_enum.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MQTT_5fCommunication_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MQTT_5fCommunication_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_MQTT_5fCommunication_2eproto;
namespace dispatch {
class ActionRequest;
struct ActionRequestDefaultTypeInternal;
extern ActionRequestDefaultTypeInternal _ActionRequest_default_instance_;
class ActionResponse;
struct ActionResponseDefaultTypeInternal;
extern ActionResponseDefaultTypeInternal _ActionResponse_default_instance_;
class Current_path;
struct Current_pathDefaultTypeInternal;
extern Current_pathDefaultTypeInternal _Current_path_default_instance_;
class Current_pose;
struct Current_poseDefaultTypeInternal;
extern Current_poseDefaultTypeInternal _Current_pose_default_instance_;
class Current_twist;
struct Current_twistDefaultTypeInternal;
extern Current_twistDefaultTypeInternal _Current_twist_default_instance_;
class EmergencyBrake;
struct EmergencyBrakeDefaultTypeInternal;
extern EmergencyBrakeDefaultTypeInternal _EmergencyBrake_default_instance_;
class FaultInformation;
struct FaultInformationDefaultTypeInternal;
extern FaultInformationDefaultTypeInternal _FaultInformation_default_instance_;
class Goal_pose;
struct Goal_poseDefaultTypeInternal;
extern Goal_poseDefaultTypeInternal _Goal_pose_default_instance_;
class Goal_twist;
struct Goal_twistDefaultTypeInternal;
extern Goal_twistDefaultTypeInternal _Goal_twist_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Heartbeat;
struct HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
class HeartbeatACK;
struct HeartbeatACKDefaultTypeInternal;
extern HeartbeatACKDefaultTypeInternal _HeartbeatACK_default_instance_;
class MsgHeader;
struct MsgHeaderDefaultTypeInternal;
extern MsgHeaderDefaultTypeInternal _MsgHeader_default_instance_;
class Multiple_goal;
struct Multiple_goalDefaultTypeInternal;
extern Multiple_goalDefaultTypeInternal _Multiple_goal_default_instance_;
class Path;
struct PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Pose;
struct PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class PoseStamped;
struct PoseStampedDefaultTypeInternal;
extern PoseStampedDefaultTypeInternal _PoseStamped_default_instance_;
class Quaternion;
struct QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class TaskRequest;
struct TaskRequestDefaultTypeInternal;
extern TaskRequestDefaultTypeInternal _TaskRequest_default_instance_;
class TaskResult;
struct TaskResultDefaultTypeInternal;
extern TaskResultDefaultTypeInternal _TaskResult_default_instance_;
class Time;
struct TimeDefaultTypeInternal;
extern TimeDefaultTypeInternal _Time_default_instance_;
class Twist;
struct TwistDefaultTypeInternal;
extern TwistDefaultTypeInternal _Twist_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
class VehicleInfo;
struct VehicleInfoDefaultTypeInternal;
extern VehicleInfoDefaultTypeInternal _VehicleInfo_default_instance_;
}  // namespace dispatch
PROTOBUF_NAMESPACE_OPEN
template<> ::dispatch::ActionRequest* Arena::CreateMaybeMessage<::dispatch::ActionRequest>(Arena*);
template<> ::dispatch::ActionResponse* Arena::CreateMaybeMessage<::dispatch::ActionResponse>(Arena*);
template<> ::dispatch::Current_path* Arena::CreateMaybeMessage<::dispatch::Current_path>(Arena*);
template<> ::dispatch::Current_pose* Arena::CreateMaybeMessage<::dispatch::Current_pose>(Arena*);
template<> ::dispatch::Current_twist* Arena::CreateMaybeMessage<::dispatch::Current_twist>(Arena*);
template<> ::dispatch::EmergencyBrake* Arena::CreateMaybeMessage<::dispatch::EmergencyBrake>(Arena*);
template<> ::dispatch::FaultInformation* Arena::CreateMaybeMessage<::dispatch::FaultInformation>(Arena*);
template<> ::dispatch::Goal_pose* Arena::CreateMaybeMessage<::dispatch::Goal_pose>(Arena*);
template<> ::dispatch::Goal_twist* Arena::CreateMaybeMessage<::dispatch::Goal_twist>(Arena*);
template<> ::dispatch::Header* Arena::CreateMaybeMessage<::dispatch::Header>(Arena*);
template<> ::dispatch::Heartbeat* Arena::CreateMaybeMessage<::dispatch::Heartbeat>(Arena*);
template<> ::dispatch::HeartbeatACK* Arena::CreateMaybeMessage<::dispatch::HeartbeatACK>(Arena*);
template<> ::dispatch::MsgHeader* Arena::CreateMaybeMessage<::dispatch::MsgHeader>(Arena*);
template<> ::dispatch::Multiple_goal* Arena::CreateMaybeMessage<::dispatch::Multiple_goal>(Arena*);
template<> ::dispatch::Path* Arena::CreateMaybeMessage<::dispatch::Path>(Arena*);
template<> ::dispatch::Point* Arena::CreateMaybeMessage<::dispatch::Point>(Arena*);
template<> ::dispatch::Pose* Arena::CreateMaybeMessage<::dispatch::Pose>(Arena*);
template<> ::dispatch::PoseStamped* Arena::CreateMaybeMessage<::dispatch::PoseStamped>(Arena*);
template<> ::dispatch::Quaternion* Arena::CreateMaybeMessage<::dispatch::Quaternion>(Arena*);
template<> ::dispatch::TaskRequest* Arena::CreateMaybeMessage<::dispatch::TaskRequest>(Arena*);
template<> ::dispatch::TaskResult* Arena::CreateMaybeMessage<::dispatch::TaskResult>(Arena*);
template<> ::dispatch::Time* Arena::CreateMaybeMessage<::dispatch::Time>(Arena*);
template<> ::dispatch::Twist* Arena::CreateMaybeMessage<::dispatch::Twist>(Arena*);
template<> ::dispatch::Vector3* Arena::CreateMaybeMessage<::dispatch::Vector3>(Arena*);
template<> ::dispatch::VehicleInfo* Arena::CreateMaybeMessage<::dispatch::VehicleInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace dispatch {

// ===================================================================

class Time final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.Time) */ {
 public:
  inline Time() : Time(nullptr) {}
  ~Time() override;
  explicit PROTOBUF_CONSTEXPR Time(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Time(const Time& from);
  Time(Time&& from) noexcept
    : Time() {
    *this = ::std::move(from);
  }

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }
  inline Time& operator=(Time&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Time& default_instance() {
    return *internal_default_instance();
  }
  static inline const Time* internal_default_instance() {
    return reinterpret_cast<const Time*>(
               &_Time_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Time& a, Time& b) {
    a.Swap(&b);
  }
  inline void Swap(Time* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Time* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Time* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Time>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Time& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Time& from) {
    Time::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Time* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.Time";
  }
  protected:
  explicit Time(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecFieldNumber = 1,
    kNsecFieldNumber = 2,
  };
  // int32 sec = 1;
  void clear_sec();
  int32_t sec() const;
  void set_sec(int32_t value);
  private:
  int32_t _internal_sec() const;
  void _internal_set_sec(int32_t value);
  public:

  // int32 nsec = 2;
  void clear_nsec();
  int32_t nsec() const;
  void set_nsec(int32_t value);
  private:
  int32_t _internal_nsec() const;
  void _internal_set_nsec(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dispatch.Time)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t sec_;
    int32_t nsec_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  explicit PROTOBUF_CONSTEXPR Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Header& from) {
    Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameIdFieldNumber = 2,
    kStampFieldNumber = 1,
  };
  // string frame_id = 2;
  void clear_frame_id();
  const std::string& frame_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_id();
  PROTOBUF_NODISCARD std::string* release_frame_id();
  void set_allocated_frame_id(std::string* frame_id);
  private:
  const std::string& _internal_frame_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_id(const std::string& value);
  std::string* _internal_mutable_frame_id();
  public:

  // .dispatch.Time stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::dispatch::Time& stamp() const;
  PROTOBUF_NODISCARD ::dispatch::Time* release_stamp();
  ::dispatch::Time* mutable_stamp();
  void set_allocated_stamp(::dispatch::Time* stamp);
  private:
  const ::dispatch::Time& _internal_stamp() const;
  ::dispatch::Time* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::dispatch::Time* stamp);
  ::dispatch::Time* unsafe_arena_release_stamp();

  // @@protoc_insertion_point(class_scope:dispatch.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_id_;
    ::dispatch::Time* stamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  explicit PROTOBUF_CONSTEXPR Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point& from) {
    Point::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:dispatch.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double x_;
    double y_;
    double z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class Quaternion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  ~Quaternion() override;
  explicit PROTOBUF_CONSTEXPR Quaternion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Quaternion(const Quaternion& from);
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Quaternion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Quaternion& from) {
    Quaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.Quaternion";
  }
  protected:
  explicit Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // double w = 4;
  void clear_w();
  double w() const;
  void set_w(double value);
  private:
  double _internal_w() const;
  void _internal_set_w(double value);
  public:

  // @@protoc_insertion_point(class_scope:dispatch.Quaternion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double x_;
    double y_;
    double z_;
    double w_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class Pose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.Pose) */ {
 public:
  inline Pose() : Pose(nullptr) {}
  ~Pose() override;
  explicit PROTOBUF_CONSTEXPR Pose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pose(const Pose& from);
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pose& operator=(Pose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pose& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(Pose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pose& from) {
    Pose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.Pose";
  }
  protected:
  explicit Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kOrientationFieldNumber = 2,
  };
  // .dispatch.Point position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::dispatch::Point& position() const;
  PROTOBUF_NODISCARD ::dispatch::Point* release_position();
  ::dispatch::Point* mutable_position();
  void set_allocated_position(::dispatch::Point* position);
  private:
  const ::dispatch::Point& _internal_position() const;
  ::dispatch::Point* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::dispatch::Point* position);
  ::dispatch::Point* unsafe_arena_release_position();

  // .dispatch.Quaternion orientation = 2;
  bool has_orientation() const;
  private:
  bool _internal_has_orientation() const;
  public:
  void clear_orientation();
  const ::dispatch::Quaternion& orientation() const;
  PROTOBUF_NODISCARD ::dispatch::Quaternion* release_orientation();
  ::dispatch::Quaternion* mutable_orientation();
  void set_allocated_orientation(::dispatch::Quaternion* orientation);
  private:
  const ::dispatch::Quaternion& _internal_orientation() const;
  ::dispatch::Quaternion* _internal_mutable_orientation();
  public:
  void unsafe_arena_set_allocated_orientation(
      ::dispatch::Quaternion* orientation);
  ::dispatch::Quaternion* unsafe_arena_release_orientation();

  // @@protoc_insertion_point(class_scope:dispatch.Pose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dispatch::Point* position_;
    ::dispatch::Quaternion* orientation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class PoseStamped final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.PoseStamped) */ {
 public:
  inline PoseStamped() : PoseStamped(nullptr) {}
  ~PoseStamped() override;
  explicit PROTOBUF_CONSTEXPR PoseStamped(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PoseStamped(const PoseStamped& from);
  PoseStamped(PoseStamped&& from) noexcept
    : PoseStamped() {
    *this = ::std::move(from);
  }

  inline PoseStamped& operator=(const PoseStamped& from) {
    CopyFrom(from);
    return *this;
  }
  inline PoseStamped& operator=(PoseStamped&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PoseStamped& default_instance() {
    return *internal_default_instance();
  }
  static inline const PoseStamped* internal_default_instance() {
    return reinterpret_cast<const PoseStamped*>(
               &_PoseStamped_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PoseStamped& a, PoseStamped& b) {
    a.Swap(&b);
  }
  inline void Swap(PoseStamped* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PoseStamped* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PoseStamped* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PoseStamped>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PoseStamped& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PoseStamped& from) {
    PoseStamped::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PoseStamped* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.PoseStamped";
  }
  protected:
  explicit PoseStamped(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPoseFieldNumber = 2,
  };
  // .dispatch.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::dispatch::Header& header() const;
  PROTOBUF_NODISCARD ::dispatch::Header* release_header();
  ::dispatch::Header* mutable_header();
  void set_allocated_header(::dispatch::Header* header);
  private:
  const ::dispatch::Header& _internal_header() const;
  ::dispatch::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::dispatch::Header* header);
  ::dispatch::Header* unsafe_arena_release_header();

  // .dispatch.Pose pose = 2;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::dispatch::Pose& pose() const;
  PROTOBUF_NODISCARD ::dispatch::Pose* release_pose();
  ::dispatch::Pose* mutable_pose();
  void set_allocated_pose(::dispatch::Pose* pose);
  private:
  const ::dispatch::Pose& _internal_pose() const;
  ::dispatch::Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::dispatch::Pose* pose);
  ::dispatch::Pose* unsafe_arena_release_pose();

  // @@protoc_insertion_point(class_scope:dispatch.PoseStamped)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dispatch::Header* header_;
    ::dispatch::Pose* pose_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class Path final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.Path) */ {
 public:
  inline Path() : Path(nullptr) {}
  ~Path() override;
  explicit PROTOBUF_CONSTEXPR Path(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Path(const Path& from);
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path& operator=(Path&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Path& default_instance() {
    return *internal_default_instance();
  }
  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }
  inline void Swap(Path* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Path>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Path& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Path& from) {
    Path::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.Path";
  }
  protected:
  explicit Path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .dispatch.PoseStamped pose = 2;
  int pose_size() const;
  private:
  int _internal_pose_size() const;
  public:
  void clear_pose();
  ::dispatch::PoseStamped* mutable_pose(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dispatch::PoseStamped >*
      mutable_pose();
  private:
  const ::dispatch::PoseStamped& _internal_pose(int index) const;
  ::dispatch::PoseStamped* _internal_add_pose();
  public:
  const ::dispatch::PoseStamped& pose(int index) const;
  ::dispatch::PoseStamped* add_pose();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dispatch::PoseStamped >&
      pose() const;

  // .dispatch.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::dispatch::Header& header() const;
  PROTOBUF_NODISCARD ::dispatch::Header* release_header();
  ::dispatch::Header* mutable_header();
  void set_allocated_header(::dispatch::Header* header);
  private:
  const ::dispatch::Header& _internal_header() const;
  ::dispatch::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::dispatch::Header* header);
  ::dispatch::Header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:dispatch.Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dispatch::PoseStamped > pose_;
    ::dispatch::Header* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class Vector3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() override;
  explicit PROTOBUF_CONSTEXPR Vector3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3(const Vector3& from);
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vector3& from) {
    Vector3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.Vector3";
  }
  protected:
  explicit Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:dispatch.Vector3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double x_;
    double y_;
    double z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class Twist final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.Twist) */ {
 public:
  inline Twist() : Twist(nullptr) {}
  ~Twist() override;
  explicit PROTOBUF_CONSTEXPR Twist(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Twist(const Twist& from);
  Twist(Twist&& from) noexcept
    : Twist() {
    *this = ::std::move(from);
  }

  inline Twist& operator=(const Twist& from) {
    CopyFrom(from);
    return *this;
  }
  inline Twist& operator=(Twist&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Twist& default_instance() {
    return *internal_default_instance();
  }
  static inline const Twist* internal_default_instance() {
    return reinterpret_cast<const Twist*>(
               &_Twist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Twist& a, Twist& b) {
    a.Swap(&b);
  }
  inline void Swap(Twist* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Twist* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Twist* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Twist>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Twist& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Twist& from) {
    Twist::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Twist* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.Twist";
  }
  protected:
  explicit Twist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kAngularFieldNumber = 2,
  };
  // .dispatch.Vector3 linear = 1;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;
  public:
  void clear_linear();
  const ::dispatch::Vector3& linear() const;
  PROTOBUF_NODISCARD ::dispatch::Vector3* release_linear();
  ::dispatch::Vector3* mutable_linear();
  void set_allocated_linear(::dispatch::Vector3* linear);
  private:
  const ::dispatch::Vector3& _internal_linear() const;
  ::dispatch::Vector3* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::dispatch::Vector3* linear);
  ::dispatch::Vector3* unsafe_arena_release_linear();

  // .dispatch.Vector3 angular = 2;
  bool has_angular() const;
  private:
  bool _internal_has_angular() const;
  public:
  void clear_angular();
  const ::dispatch::Vector3& angular() const;
  PROTOBUF_NODISCARD ::dispatch::Vector3* release_angular();
  ::dispatch::Vector3* mutable_angular();
  void set_allocated_angular(::dispatch::Vector3* angular);
  private:
  const ::dispatch::Vector3& _internal_angular() const;
  ::dispatch::Vector3* _internal_mutable_angular();
  public:
  void unsafe_arena_set_allocated_angular(
      ::dispatch::Vector3* angular);
  ::dispatch::Vector3* unsafe_arena_release_angular();

  // @@protoc_insertion_point(class_scope:dispatch.Twist)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dispatch::Vector3* linear_;
    ::dispatch::Vector3* angular_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class Current_pose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.Current_pose) */ {
 public:
  inline Current_pose() : Current_pose(nullptr) {}
  ~Current_pose() override;
  explicit PROTOBUF_CONSTEXPR Current_pose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Current_pose(const Current_pose& from);
  Current_pose(Current_pose&& from) noexcept
    : Current_pose() {
    *this = ::std::move(from);
  }

  inline Current_pose& operator=(const Current_pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline Current_pose& operator=(Current_pose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Current_pose& default_instance() {
    return *internal_default_instance();
  }
  static inline const Current_pose* internal_default_instance() {
    return reinterpret_cast<const Current_pose*>(
               &_Current_pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Current_pose& a, Current_pose& b) {
    a.Swap(&b);
  }
  inline void Swap(Current_pose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Current_pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Current_pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Current_pose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Current_pose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Current_pose& from) {
    Current_pose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Current_pose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.Current_pose";
  }
  protected:
  explicit Current_pose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
  };
  // .dispatch.Pose pose = 1;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::dispatch::Pose& pose() const;
  PROTOBUF_NODISCARD ::dispatch::Pose* release_pose();
  ::dispatch::Pose* mutable_pose();
  void set_allocated_pose(::dispatch::Pose* pose);
  private:
  const ::dispatch::Pose& _internal_pose() const;
  ::dispatch::Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::dispatch::Pose* pose);
  ::dispatch::Pose* unsafe_arena_release_pose();

  // @@protoc_insertion_point(class_scope:dispatch.Current_pose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dispatch::Pose* pose_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class Current_twist final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.Current_twist) */ {
 public:
  inline Current_twist() : Current_twist(nullptr) {}
  ~Current_twist() override;
  explicit PROTOBUF_CONSTEXPR Current_twist(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Current_twist(const Current_twist& from);
  Current_twist(Current_twist&& from) noexcept
    : Current_twist() {
    *this = ::std::move(from);
  }

  inline Current_twist& operator=(const Current_twist& from) {
    CopyFrom(from);
    return *this;
  }
  inline Current_twist& operator=(Current_twist&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Current_twist& default_instance() {
    return *internal_default_instance();
  }
  static inline const Current_twist* internal_default_instance() {
    return reinterpret_cast<const Current_twist*>(
               &_Current_twist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Current_twist& a, Current_twist& b) {
    a.Swap(&b);
  }
  inline void Swap(Current_twist* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Current_twist* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Current_twist* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Current_twist>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Current_twist& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Current_twist& from) {
    Current_twist::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Current_twist* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.Current_twist";
  }
  protected:
  explicit Current_twist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTwistFieldNumber = 1,
  };
  // .dispatch.Twist twist = 1;
  bool has_twist() const;
  private:
  bool _internal_has_twist() const;
  public:
  void clear_twist();
  const ::dispatch::Twist& twist() const;
  PROTOBUF_NODISCARD ::dispatch::Twist* release_twist();
  ::dispatch::Twist* mutable_twist();
  void set_allocated_twist(::dispatch::Twist* twist);
  private:
  const ::dispatch::Twist& _internal_twist() const;
  ::dispatch::Twist* _internal_mutable_twist();
  public:
  void unsafe_arena_set_allocated_twist(
      ::dispatch::Twist* twist);
  ::dispatch::Twist* unsafe_arena_release_twist();

  // @@protoc_insertion_point(class_scope:dispatch.Current_twist)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dispatch::Twist* twist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class Goal_pose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.Goal_pose) */ {
 public:
  inline Goal_pose() : Goal_pose(nullptr) {}
  ~Goal_pose() override;
  explicit PROTOBUF_CONSTEXPR Goal_pose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Goal_pose(const Goal_pose& from);
  Goal_pose(Goal_pose&& from) noexcept
    : Goal_pose() {
    *this = ::std::move(from);
  }

  inline Goal_pose& operator=(const Goal_pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline Goal_pose& operator=(Goal_pose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Goal_pose& default_instance() {
    return *internal_default_instance();
  }
  static inline const Goal_pose* internal_default_instance() {
    return reinterpret_cast<const Goal_pose*>(
               &_Goal_pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Goal_pose& a, Goal_pose& b) {
    a.Swap(&b);
  }
  inline void Swap(Goal_pose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Goal_pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Goal_pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Goal_pose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Goal_pose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Goal_pose& from) {
    Goal_pose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Goal_pose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.Goal_pose";
  }
  protected:
  explicit Goal_pose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
  };
  // .dispatch.Pose pose = 1;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::dispatch::Pose& pose() const;
  PROTOBUF_NODISCARD ::dispatch::Pose* release_pose();
  ::dispatch::Pose* mutable_pose();
  void set_allocated_pose(::dispatch::Pose* pose);
  private:
  const ::dispatch::Pose& _internal_pose() const;
  ::dispatch::Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::dispatch::Pose* pose);
  ::dispatch::Pose* unsafe_arena_release_pose();

  // @@protoc_insertion_point(class_scope:dispatch.Goal_pose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dispatch::Pose* pose_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class Current_path final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.Current_path) */ {
 public:
  inline Current_path() : Current_path(nullptr) {}
  ~Current_path() override;
  explicit PROTOBUF_CONSTEXPR Current_path(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Current_path(const Current_path& from);
  Current_path(Current_path&& from) noexcept
    : Current_path() {
    *this = ::std::move(from);
  }

  inline Current_path& operator=(const Current_path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Current_path& operator=(Current_path&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Current_path& default_instance() {
    return *internal_default_instance();
  }
  static inline const Current_path* internal_default_instance() {
    return reinterpret_cast<const Current_path*>(
               &_Current_path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Current_path& a, Current_path& b) {
    a.Swap(&b);
  }
  inline void Swap(Current_path* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Current_path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Current_path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Current_path>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Current_path& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Current_path& from) {
    Current_path::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Current_path* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.Current_path";
  }
  protected:
  explicit Current_path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
  };
  // repeated .dispatch.Pose pose = 1;
  int pose_size() const;
  private:
  int _internal_pose_size() const;
  public:
  void clear_pose();
  ::dispatch::Pose* mutable_pose(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dispatch::Pose >*
      mutable_pose();
  private:
  const ::dispatch::Pose& _internal_pose(int index) const;
  ::dispatch::Pose* _internal_add_pose();
  public:
  const ::dispatch::Pose& pose(int index) const;
  ::dispatch::Pose* add_pose();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dispatch::Pose >&
      pose() const;

  // @@protoc_insertion_point(class_scope:dispatch.Current_path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dispatch::Pose > pose_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class Goal_twist final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.Goal_twist) */ {
 public:
  inline Goal_twist() : Goal_twist(nullptr) {}
  ~Goal_twist() override;
  explicit PROTOBUF_CONSTEXPR Goal_twist(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Goal_twist(const Goal_twist& from);
  Goal_twist(Goal_twist&& from) noexcept
    : Goal_twist() {
    *this = ::std::move(from);
  }

  inline Goal_twist& operator=(const Goal_twist& from) {
    CopyFrom(from);
    return *this;
  }
  inline Goal_twist& operator=(Goal_twist&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Goal_twist& default_instance() {
    return *internal_default_instance();
  }
  static inline const Goal_twist* internal_default_instance() {
    return reinterpret_cast<const Goal_twist*>(
               &_Goal_twist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Goal_twist& a, Goal_twist& b) {
    a.Swap(&b);
  }
  inline void Swap(Goal_twist* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Goal_twist* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Goal_twist* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Goal_twist>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Goal_twist& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Goal_twist& from) {
    Goal_twist::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Goal_twist* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.Goal_twist";
  }
  protected:
  explicit Goal_twist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTwistFieldNumber = 1,
  };
  // .dispatch.Twist twist = 1;
  bool has_twist() const;
  private:
  bool _internal_has_twist() const;
  public:
  void clear_twist();
  const ::dispatch::Twist& twist() const;
  PROTOBUF_NODISCARD ::dispatch::Twist* release_twist();
  ::dispatch::Twist* mutable_twist();
  void set_allocated_twist(::dispatch::Twist* twist);
  private:
  const ::dispatch::Twist& _internal_twist() const;
  ::dispatch::Twist* _internal_mutable_twist();
  public:
  void unsafe_arena_set_allocated_twist(
      ::dispatch::Twist* twist);
  ::dispatch::Twist* unsafe_arena_release_twist();

  // @@protoc_insertion_point(class_scope:dispatch.Goal_twist)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dispatch::Twist* twist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class Multiple_goal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.Multiple_goal) */ {
 public:
  inline Multiple_goal() : Multiple_goal(nullptr) {}
  ~Multiple_goal() override;
  explicit PROTOBUF_CONSTEXPR Multiple_goal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Multiple_goal(const Multiple_goal& from);
  Multiple_goal(Multiple_goal&& from) noexcept
    : Multiple_goal() {
    *this = ::std::move(from);
  }

  inline Multiple_goal& operator=(const Multiple_goal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Multiple_goal& operator=(Multiple_goal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Multiple_goal& default_instance() {
    return *internal_default_instance();
  }
  static inline const Multiple_goal* internal_default_instance() {
    return reinterpret_cast<const Multiple_goal*>(
               &_Multiple_goal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Multiple_goal& a, Multiple_goal& b) {
    a.Swap(&b);
  }
  inline void Swap(Multiple_goal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Multiple_goal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Multiple_goal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Multiple_goal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Multiple_goal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Multiple_goal& from) {
    Multiple_goal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Multiple_goal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.Multiple_goal";
  }
  protected:
  explicit Multiple_goal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
  };
  // repeated .dispatch.PoseStamped pose = 1;
  int pose_size() const;
  private:
  int _internal_pose_size() const;
  public:
  void clear_pose();
  ::dispatch::PoseStamped* mutable_pose(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dispatch::PoseStamped >*
      mutable_pose();
  private:
  const ::dispatch::PoseStamped& _internal_pose(int index) const;
  ::dispatch::PoseStamped* _internal_add_pose();
  public:
  const ::dispatch::PoseStamped& pose(int index) const;
  ::dispatch::PoseStamped* add_pose();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dispatch::PoseStamped >&
      pose() const;

  // @@protoc_insertion_point(class_scope:dispatch.Multiple_goal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dispatch::PoseStamped > pose_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class MsgHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.MsgHeader) */ {
 public:
  inline MsgHeader() : MsgHeader(nullptr) {}
  ~MsgHeader() override;
  explicit PROTOBUF_CONSTEXPR MsgHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgHeader(const MsgHeader& from);
  MsgHeader(MsgHeader&& from) noexcept
    : MsgHeader() {
    *this = ::std::move(from);
  }

  inline MsgHeader& operator=(const MsgHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgHeader& operator=(MsgHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgHeader* internal_default_instance() {
    return reinterpret_cast<const MsgHeader*>(
               &_MsgHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MsgHeader& a, MsgHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgHeader& from) {
    MsgHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.MsgHeader";
  }
  protected:
  explicit MsgHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kMsgIdFieldNumber = 2,
  };
  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 msg_id = 2;
  void clear_msg_id();
  uint32_t msg_id() const;
  void set_msg_id(uint32_t value);
  private:
  uint32_t _internal_msg_id() const;
  void _internal_set_msg_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dispatch.MsgHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t timestamp_;
    uint32_t msg_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class VehicleInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.VehicleInfo) */ {
 public:
  inline VehicleInfo() : VehicleInfo(nullptr) {}
  ~VehicleInfo() override;
  explicit PROTOBUF_CONSTEXPR VehicleInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VehicleInfo(const VehicleInfo& from);
  VehicleInfo(VehicleInfo&& from) noexcept
    : VehicleInfo() {
    *this = ::std::move(from);
  }

  inline VehicleInfo& operator=(const VehicleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleInfo& operator=(VehicleInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleInfo* internal_default_instance() {
    return reinterpret_cast<const VehicleInfo*>(
               &_VehicleInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VehicleInfo& a, VehicleInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VehicleInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VehicleInfo& from) {
    VehicleInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.VehicleInfo";
  }
  protected:
  explicit VehicleInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPoseFieldNumber = 2,
    kTwistFieldNumber = 3,
    kMotionFieldNumber = 4,
    kDrivingModeFieldNumber = 5,
  };
  // .dispatch.MsgHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::dispatch::MsgHeader& header() const;
  PROTOBUF_NODISCARD ::dispatch::MsgHeader* release_header();
  ::dispatch::MsgHeader* mutable_header();
  void set_allocated_header(::dispatch::MsgHeader* header);
  private:
  const ::dispatch::MsgHeader& _internal_header() const;
  ::dispatch::MsgHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::dispatch::MsgHeader* header);
  ::dispatch::MsgHeader* unsafe_arena_release_header();

  // .dispatch.Pose pose = 2;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::dispatch::Pose& pose() const;
  PROTOBUF_NODISCARD ::dispatch::Pose* release_pose();
  ::dispatch::Pose* mutable_pose();
  void set_allocated_pose(::dispatch::Pose* pose);
  private:
  const ::dispatch::Pose& _internal_pose() const;
  ::dispatch::Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::dispatch::Pose* pose);
  ::dispatch::Pose* unsafe_arena_release_pose();

  // .dispatch.Twist twist = 3;
  bool has_twist() const;
  private:
  bool _internal_has_twist() const;
  public:
  void clear_twist();
  const ::dispatch::Twist& twist() const;
  PROTOBUF_NODISCARD ::dispatch::Twist* release_twist();
  ::dispatch::Twist* mutable_twist();
  void set_allocated_twist(::dispatch::Twist* twist);
  private:
  const ::dispatch::Twist& _internal_twist() const;
  ::dispatch::Twist* _internal_mutable_twist();
  public:
  void unsafe_arena_set_allocated_twist(
      ::dispatch::Twist* twist);
  ::dispatch::Twist* unsafe_arena_release_twist();

  // .dispatch.VehicleMotionState motion = 4;
  void clear_motion();
  ::dispatch::VehicleMotionState motion() const;
  void set_motion(::dispatch::VehicleMotionState value);
  private:
  ::dispatch::VehicleMotionState _internal_motion() const;
  void _internal_set_motion(::dispatch::VehicleMotionState value);
  public:

  // .dispatch.DrivingMode driving_mode = 5;
  void clear_driving_mode();
  ::dispatch::DrivingMode driving_mode() const;
  void set_driving_mode(::dispatch::DrivingMode value);
  private:
  ::dispatch::DrivingMode _internal_driving_mode() const;
  void _internal_set_driving_mode(::dispatch::DrivingMode value);
  public:

  // @@protoc_insertion_point(class_scope:dispatch.VehicleInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dispatch::MsgHeader* header_;
    ::dispatch::Pose* pose_;
    ::dispatch::Twist* twist_;
    int motion_;
    int driving_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class ActionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.ActionRequest) */ {
 public:
  inline ActionRequest() : ActionRequest(nullptr) {}
  ~ActionRequest() override;
  explicit PROTOBUF_CONSTEXPR ActionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionRequest(const ActionRequest& from);
  ActionRequest(ActionRequest&& from) noexcept
    : ActionRequest() {
    *this = ::std::move(from);
  }

  inline ActionRequest& operator=(const ActionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionRequest& operator=(ActionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionRequest* internal_default_instance() {
    return reinterpret_cast<const ActionRequest*>(
               &_ActionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ActionRequest& a, ActionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionRequest& from) {
    ActionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.ActionRequest";
  }
  protected:
  explicit ActionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPathFieldNumber = 3,
    kGoalFieldNumber = 4,
    kActionTypeFieldNumber = 2,
    kParkIdFieldNumber = 5,
  };
  // .dispatch.MsgHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::dispatch::MsgHeader& header() const;
  PROTOBUF_NODISCARD ::dispatch::MsgHeader* release_header();
  ::dispatch::MsgHeader* mutable_header();
  void set_allocated_header(::dispatch::MsgHeader* header);
  private:
  const ::dispatch::MsgHeader& _internal_header() const;
  ::dispatch::MsgHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::dispatch::MsgHeader* header);
  ::dispatch::MsgHeader* unsafe_arena_release_header();

  // .dispatch.Current_path path = 3;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::dispatch::Current_path& path() const;
  PROTOBUF_NODISCARD ::dispatch::Current_path* release_path();
  ::dispatch::Current_path* mutable_path();
  void set_allocated_path(::dispatch::Current_path* path);
  private:
  const ::dispatch::Current_path& _internal_path() const;
  ::dispatch::Current_path* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::dispatch::Current_path* path);
  ::dispatch::Current_path* unsafe_arena_release_path();

  // .dispatch.Goal_pose goal = 4;
  bool has_goal() const;
  private:
  bool _internal_has_goal() const;
  public:
  void clear_goal();
  const ::dispatch::Goal_pose& goal() const;
  PROTOBUF_NODISCARD ::dispatch::Goal_pose* release_goal();
  ::dispatch::Goal_pose* mutable_goal();
  void set_allocated_goal(::dispatch::Goal_pose* goal);
  private:
  const ::dispatch::Goal_pose& _internal_goal() const;
  ::dispatch::Goal_pose* _internal_mutable_goal();
  public:
  void unsafe_arena_set_allocated_goal(
      ::dispatch::Goal_pose* goal);
  ::dispatch::Goal_pose* unsafe_arena_release_goal();

  // .dispatch.ActionType action_type = 2;
  void clear_action_type();
  ::dispatch::ActionType action_type() const;
  void set_action_type(::dispatch::ActionType value);
  private:
  ::dispatch::ActionType _internal_action_type() const;
  void _internal_set_action_type(::dispatch::ActionType value);
  public:

  // uint32 park_id = 5;
  void clear_park_id();
  uint32_t park_id() const;
  void set_park_id(uint32_t value);
  private:
  uint32_t _internal_park_id() const;
  void _internal_set_park_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dispatch.ActionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dispatch::MsgHeader* header_;
    ::dispatch::Current_path* path_;
    ::dispatch::Goal_pose* goal_;
    int action_type_;
    uint32_t park_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class ActionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.ActionResponse) */ {
 public:
  inline ActionResponse() : ActionResponse(nullptr) {}
  ~ActionResponse() override;
  explicit PROTOBUF_CONSTEXPR ActionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionResponse(const ActionResponse& from);
  ActionResponse(ActionResponse&& from) noexcept
    : ActionResponse() {
    *this = ::std::move(from);
  }

  inline ActionResponse& operator=(const ActionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionResponse& operator=(ActionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionResponse* internal_default_instance() {
    return reinterpret_cast<const ActionResponse*>(
               &_ActionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ActionResponse& a, ActionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionResponse& from) {
    ActionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.ActionResponse";
  }
  protected:
  explicit ActionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // string error_msg = 3;
  void clear_error_msg();
  const std::string& error_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_msg();
  PROTOBUF_NODISCARD std::string* release_error_msg();
  void set_allocated_error_msg(std::string* error_msg);
  private:
  const std::string& _internal_error_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_msg(const std::string& value);
  std::string* _internal_mutable_error_msg();
  public:

  // .dispatch.MsgHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::dispatch::MsgHeader& header() const;
  PROTOBUF_NODISCARD ::dispatch::MsgHeader* release_header();
  ::dispatch::MsgHeader* mutable_header();
  void set_allocated_header(::dispatch::MsgHeader* header);
  private:
  const ::dispatch::MsgHeader& _internal_header() const;
  ::dispatch::MsgHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::dispatch::MsgHeader* header);
  ::dispatch::MsgHeader* unsafe_arena_release_header();

  // int32 error_code = 2;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dispatch.ActionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_msg_;
    ::dispatch::MsgHeader* header_;
    int32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class TaskRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.TaskRequest) */ {
 public:
  inline TaskRequest() : TaskRequest(nullptr) {}
  ~TaskRequest() override;
  explicit PROTOBUF_CONSTEXPR TaskRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskRequest(const TaskRequest& from);
  TaskRequest(TaskRequest&& from) noexcept
    : TaskRequest() {
    *this = ::std::move(from);
  }

  inline TaskRequest& operator=(const TaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskRequest& operator=(TaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskRequest* internal_default_instance() {
    return reinterpret_cast<const TaskRequest*>(
               &_TaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TaskRequest& a, TaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskRequest& from) {
    TaskRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.TaskRequest";
  }
  protected:
  explicit TaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kTaskTypeFieldNumber = 2,
    kAreaIdFieldNumber = 3,
  };
  // .dispatch.MsgHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::dispatch::MsgHeader& header() const;
  PROTOBUF_NODISCARD ::dispatch::MsgHeader* release_header();
  ::dispatch::MsgHeader* mutable_header();
  void set_allocated_header(::dispatch::MsgHeader* header);
  private:
  const ::dispatch::MsgHeader& _internal_header() const;
  ::dispatch::MsgHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::dispatch::MsgHeader* header);
  ::dispatch::MsgHeader* unsafe_arena_release_header();

  // .dispatch.TaskType task_type = 2;
  void clear_task_type();
  ::dispatch::TaskType task_type() const;
  void set_task_type(::dispatch::TaskType value);
  private:
  ::dispatch::TaskType _internal_task_type() const;
  void _internal_set_task_type(::dispatch::TaskType value);
  public:

  // uint32 area_id = 3;
  void clear_area_id();
  uint32_t area_id() const;
  void set_area_id(uint32_t value);
  private:
  uint32_t _internal_area_id() const;
  void _internal_set_area_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dispatch.TaskRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dispatch::MsgHeader* header_;
    int task_type_;
    uint32_t area_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class TaskResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.TaskResult) */ {
 public:
  inline TaskResult() : TaskResult(nullptr) {}
  ~TaskResult() override;
  explicit PROTOBUF_CONSTEXPR TaskResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskResult(const TaskResult& from);
  TaskResult(TaskResult&& from) noexcept
    : TaskResult() {
    *this = ::std::move(from);
  }

  inline TaskResult& operator=(const TaskResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskResult& operator=(TaskResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskResult* internal_default_instance() {
    return reinterpret_cast<const TaskResult*>(
               &_TaskResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TaskResult& a, TaskResult& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskResult& from) {
    TaskResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.TaskResult";
  }
  protected:
  explicit TaskResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kTaskTypeFieldNumber = 2,
    kErrorCodeFieldNumber = 3,
  };
  // string error_msg = 4;
  void clear_error_msg();
  const std::string& error_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_msg();
  PROTOBUF_NODISCARD std::string* release_error_msg();
  void set_allocated_error_msg(std::string* error_msg);
  private:
  const std::string& _internal_error_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_msg(const std::string& value);
  std::string* _internal_mutable_error_msg();
  public:

  // .dispatch.MsgHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::dispatch::MsgHeader& header() const;
  PROTOBUF_NODISCARD ::dispatch::MsgHeader* release_header();
  ::dispatch::MsgHeader* mutable_header();
  void set_allocated_header(::dispatch::MsgHeader* header);
  private:
  const ::dispatch::MsgHeader& _internal_header() const;
  ::dispatch::MsgHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::dispatch::MsgHeader* header);
  ::dispatch::MsgHeader* unsafe_arena_release_header();

  // .dispatch.TaskType task_type = 2;
  void clear_task_type();
  ::dispatch::TaskType task_type() const;
  void set_task_type(::dispatch::TaskType value);
  private:
  ::dispatch::TaskType _internal_task_type() const;
  void _internal_set_task_type(::dispatch::TaskType value);
  public:

  // int32 error_code = 3;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dispatch.TaskResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_msg_;
    ::dispatch::MsgHeader* header_;
    int task_type_;
    int32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class EmergencyBrake final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.EmergencyBrake) */ {
 public:
  inline EmergencyBrake() : EmergencyBrake(nullptr) {}
  ~EmergencyBrake() override;
  explicit PROTOBUF_CONSTEXPR EmergencyBrake(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmergencyBrake(const EmergencyBrake& from);
  EmergencyBrake(EmergencyBrake&& from) noexcept
    : EmergencyBrake() {
    *this = ::std::move(from);
  }

  inline EmergencyBrake& operator=(const EmergencyBrake& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmergencyBrake& operator=(EmergencyBrake&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmergencyBrake& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmergencyBrake* internal_default_instance() {
    return reinterpret_cast<const EmergencyBrake*>(
               &_EmergencyBrake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(EmergencyBrake& a, EmergencyBrake& b) {
    a.Swap(&b);
  }
  inline void Swap(EmergencyBrake* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmergencyBrake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmergencyBrake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmergencyBrake>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmergencyBrake& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmergencyBrake& from) {
    EmergencyBrake::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmergencyBrake* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.EmergencyBrake";
  }
  protected:
  explicit EmergencyBrake(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kValidFieldNumber = 2,
  };
  // .dispatch.MsgHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::dispatch::MsgHeader& header() const;
  PROTOBUF_NODISCARD ::dispatch::MsgHeader* release_header();
  ::dispatch::MsgHeader* mutable_header();
  void set_allocated_header(::dispatch::MsgHeader* header);
  private:
  const ::dispatch::MsgHeader& _internal_header() const;
  ::dispatch::MsgHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::dispatch::MsgHeader* header);
  ::dispatch::MsgHeader* unsafe_arena_release_header();

  // bool valid = 2;
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dispatch.EmergencyBrake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dispatch::MsgHeader* header_;
    bool valid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class Heartbeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.Heartbeat) */ {
 public:
  inline Heartbeat() : Heartbeat(nullptr) {}
  ~Heartbeat() override;
  explicit PROTOBUF_CONSTEXPR Heartbeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Heartbeat(const Heartbeat& from);
  Heartbeat(Heartbeat&& from) noexcept
    : Heartbeat() {
    *this = ::std::move(from);
  }

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Heartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Heartbeat* internal_default_instance() {
    return reinterpret_cast<const Heartbeat*>(
               &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Heartbeat& a, Heartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(Heartbeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Heartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Heartbeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Heartbeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Heartbeat& from) {
    Heartbeat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Heartbeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.Heartbeat";
  }
  protected:
  explicit Heartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .dispatch.MsgHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::dispatch::MsgHeader& header() const;
  PROTOBUF_NODISCARD ::dispatch::MsgHeader* release_header();
  ::dispatch::MsgHeader* mutable_header();
  void set_allocated_header(::dispatch::MsgHeader* header);
  private:
  const ::dispatch::MsgHeader& _internal_header() const;
  ::dispatch::MsgHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::dispatch::MsgHeader* header);
  ::dispatch::MsgHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:dispatch.Heartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dispatch::MsgHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatACK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.HeartbeatACK) */ {
 public:
  inline HeartbeatACK() : HeartbeatACK(nullptr) {}
  ~HeartbeatACK() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatACK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatACK(const HeartbeatACK& from);
  HeartbeatACK(HeartbeatACK&& from) noexcept
    : HeartbeatACK() {
    *this = ::std::move(from);
  }

  inline HeartbeatACK& operator=(const HeartbeatACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatACK& operator=(HeartbeatACK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatACK& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatACK* internal_default_instance() {
    return reinterpret_cast<const HeartbeatACK*>(
               &_HeartbeatACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(HeartbeatACK& a, HeartbeatACK& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatACK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatACK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatACK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatACK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatACK& from) {
    HeartbeatACK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatACK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.HeartbeatACK";
  }
  protected:
  explicit HeartbeatACK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .dispatch.MsgHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::dispatch::MsgHeader& header() const;
  PROTOBUF_NODISCARD ::dispatch::MsgHeader* release_header();
  ::dispatch::MsgHeader* mutable_header();
  void set_allocated_header(::dispatch::MsgHeader* header);
  private:
  const ::dispatch::MsgHeader& _internal_header() const;
  ::dispatch::MsgHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::dispatch::MsgHeader* header);
  ::dispatch::MsgHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:dispatch.HeartbeatACK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dispatch::MsgHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// -------------------------------------------------------------------

class FaultInformation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dispatch.FaultInformation) */ {
 public:
  inline FaultInformation() : FaultInformation(nullptr) {}
  ~FaultInformation() override;
  explicit PROTOBUF_CONSTEXPR FaultInformation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaultInformation(const FaultInformation& from);
  FaultInformation(FaultInformation&& from) noexcept
    : FaultInformation() {
    *this = ::std::move(from);
  }

  inline FaultInformation& operator=(const FaultInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaultInformation& operator=(FaultInformation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaultInformation& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaultInformation* internal_default_instance() {
    return reinterpret_cast<const FaultInformation*>(
               &_FaultInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(FaultInformation& a, FaultInformation& b) {
    a.Swap(&b);
  }
  inline void Swap(FaultInformation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaultInformation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaultInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaultInformation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaultInformation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FaultInformation& from) {
    FaultInformation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaultInformation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dispatch.FaultInformation";
  }
  protected:
  explicit FaultInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFaultStrFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kTypeFieldNumber = 2,
    kFaultCodeFieldNumber = 3,
  };
  // string fault_str = 4;
  void clear_fault_str();
  const std::string& fault_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fault_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fault_str();
  PROTOBUF_NODISCARD std::string* release_fault_str();
  void set_allocated_fault_str(std::string* fault_str);
  private:
  const std::string& _internal_fault_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fault_str(const std::string& value);
  std::string* _internal_mutable_fault_str();
  public:

  // .dispatch.MsgHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::dispatch::MsgHeader& header() const;
  PROTOBUF_NODISCARD ::dispatch::MsgHeader* release_header();
  ::dispatch::MsgHeader* mutable_header();
  void set_allocated_header(::dispatch::MsgHeader* header);
  private:
  const ::dispatch::MsgHeader& _internal_header() const;
  ::dispatch::MsgHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::dispatch::MsgHeader* header);
  ::dispatch::MsgHeader* unsafe_arena_release_header();

  // .dispatch.FaultType type = 2;
  void clear_type();
  ::dispatch::FaultType type() const;
  void set_type(::dispatch::FaultType value);
  private:
  ::dispatch::FaultType _internal_type() const;
  void _internal_set_type(::dispatch::FaultType value);
  public:

  // uint32 fault_code = 3;
  void clear_fault_code();
  uint32_t fault_code() const;
  void set_fault_code(uint32_t value);
  private:
  uint32_t _internal_fault_code() const;
  void _internal_set_fault_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dispatch.FaultInformation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fault_str_;
    ::dispatch::MsgHeader* header_;
    int type_;
    uint32_t fault_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MQTT_5fCommunication_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Time

// int32 sec = 1;
inline void Time::clear_sec() {
  _impl_.sec_ = 0;
}
inline int32_t Time::_internal_sec() const {
  return _impl_.sec_;
}
inline int32_t Time::sec() const {
  // @@protoc_insertion_point(field_get:dispatch.Time.sec)
  return _internal_sec();
}
inline void Time::_internal_set_sec(int32_t value) {
  
  _impl_.sec_ = value;
}
inline void Time::set_sec(int32_t value) {
  _internal_set_sec(value);
  // @@protoc_insertion_point(field_set:dispatch.Time.sec)
}

// int32 nsec = 2;
inline void Time::clear_nsec() {
  _impl_.nsec_ = 0;
}
inline int32_t Time::_internal_nsec() const {
  return _impl_.nsec_;
}
inline int32_t Time::nsec() const {
  // @@protoc_insertion_point(field_get:dispatch.Time.nsec)
  return _internal_nsec();
}
inline void Time::_internal_set_nsec(int32_t value) {
  
  _impl_.nsec_ = value;
}
inline void Time::set_nsec(int32_t value) {
  _internal_set_nsec(value);
  // @@protoc_insertion_point(field_set:dispatch.Time.nsec)
}

// -------------------------------------------------------------------

// Header

// .dispatch.Time stamp = 1;
inline bool Header::_internal_has_stamp() const {
  return this != internal_default_instance() && _impl_.stamp_ != nullptr;
}
inline bool Header::has_stamp() const {
  return _internal_has_stamp();
}
inline void Header::clear_stamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.stamp_ != nullptr) {
    delete _impl_.stamp_;
  }
  _impl_.stamp_ = nullptr;
}
inline const ::dispatch::Time& Header::_internal_stamp() const {
  const ::dispatch::Time* p = _impl_.stamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Time&>(
      ::dispatch::_Time_default_instance_);
}
inline const ::dispatch::Time& Header::stamp() const {
  // @@protoc_insertion_point(field_get:dispatch.Header.stamp)
  return _internal_stamp();
}
inline void Header::unsafe_arena_set_allocated_stamp(
    ::dispatch::Time* stamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stamp_);
  }
  _impl_.stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.Header.stamp)
}
inline ::dispatch::Time* Header::release_stamp() {
  
  ::dispatch::Time* temp = _impl_.stamp_;
  _impl_.stamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Time* Header::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:dispatch.Header.stamp)
  
  ::dispatch::Time* temp = _impl_.stamp_;
  _impl_.stamp_ = nullptr;
  return temp;
}
inline ::dispatch::Time* Header::_internal_mutable_stamp() {
  
  if (_impl_.stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Time>(GetArenaForAllocation());
    _impl_.stamp_ = p;
  }
  return _impl_.stamp_;
}
inline ::dispatch::Time* Header::mutable_stamp() {
  ::dispatch::Time* _msg = _internal_mutable_stamp();
  // @@protoc_insertion_point(field_mutable:dispatch.Header.stamp)
  return _msg;
}
inline void Header::set_allocated_stamp(::dispatch::Time* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:dispatch.Header.stamp)
}

// string frame_id = 2;
inline void Header::clear_frame_id() {
  _impl_.frame_id_.ClearToEmpty();
}
inline const std::string& Header::frame_id() const {
  // @@protoc_insertion_point(field_get:dispatch.Header.frame_id)
  return _internal_frame_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Header::set_frame_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dispatch.Header.frame_id)
}
inline std::string* Header::mutable_frame_id() {
  std::string* _s = _internal_mutable_frame_id();
  // @@protoc_insertion_point(field_mutable:dispatch.Header.frame_id)
  return _s;
}
inline const std::string& Header::_internal_frame_id() const {
  return _impl_.frame_id_.Get();
}
inline void Header::_internal_set_frame_id(const std::string& value) {
  
  _impl_.frame_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_frame_id() {
  
  return _impl_.frame_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Header::release_frame_id() {
  // @@protoc_insertion_point(field_release:dispatch.Header.frame_id)
  return _impl_.frame_id_.Release();
}
inline void Header::set_allocated_frame_id(std::string* frame_id) {
  if (frame_id != nullptr) {
    
  } else {
    
  }
  _impl_.frame_id_.SetAllocated(frame_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_id_.IsDefault()) {
    _impl_.frame_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dispatch.Header.frame_id)
}

// -------------------------------------------------------------------

// Point

// double x = 1;
inline void Point::clear_x() {
  _impl_.x_ = 0;
}
inline double Point::_internal_x() const {
  return _impl_.x_;
}
inline double Point::x() const {
  // @@protoc_insertion_point(field_get:dispatch.Point.x)
  return _internal_x();
}
inline void Point::_internal_set_x(double value) {
  
  _impl_.x_ = value;
}
inline void Point::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:dispatch.Point.x)
}

// double y = 2;
inline void Point::clear_y() {
  _impl_.y_ = 0;
}
inline double Point::_internal_y() const {
  return _impl_.y_;
}
inline double Point::y() const {
  // @@protoc_insertion_point(field_get:dispatch.Point.y)
  return _internal_y();
}
inline void Point::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void Point::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:dispatch.Point.y)
}

// double z = 3;
inline void Point::clear_z() {
  _impl_.z_ = 0;
}
inline double Point::_internal_z() const {
  return _impl_.z_;
}
inline double Point::z() const {
  // @@protoc_insertion_point(field_get:dispatch.Point.z)
  return _internal_z();
}
inline void Point::_internal_set_z(double value) {
  
  _impl_.z_ = value;
}
inline void Point::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:dispatch.Point.z)
}

// -------------------------------------------------------------------

// Quaternion

// double x = 1;
inline void Quaternion::clear_x() {
  _impl_.x_ = 0;
}
inline double Quaternion::_internal_x() const {
  return _impl_.x_;
}
inline double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:dispatch.Quaternion.x)
  return _internal_x();
}
inline void Quaternion::_internal_set_x(double value) {
  
  _impl_.x_ = value;
}
inline void Quaternion::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:dispatch.Quaternion.x)
}

// double y = 2;
inline void Quaternion::clear_y() {
  _impl_.y_ = 0;
}
inline double Quaternion::_internal_y() const {
  return _impl_.y_;
}
inline double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:dispatch.Quaternion.y)
  return _internal_y();
}
inline void Quaternion::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void Quaternion::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:dispatch.Quaternion.y)
}

// double z = 3;
inline void Quaternion::clear_z() {
  _impl_.z_ = 0;
}
inline double Quaternion::_internal_z() const {
  return _impl_.z_;
}
inline double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:dispatch.Quaternion.z)
  return _internal_z();
}
inline void Quaternion::_internal_set_z(double value) {
  
  _impl_.z_ = value;
}
inline void Quaternion::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:dispatch.Quaternion.z)
}

// double w = 4;
inline void Quaternion::clear_w() {
  _impl_.w_ = 0;
}
inline double Quaternion::_internal_w() const {
  return _impl_.w_;
}
inline double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:dispatch.Quaternion.w)
  return _internal_w();
}
inline void Quaternion::_internal_set_w(double value) {
  
  _impl_.w_ = value;
}
inline void Quaternion::set_w(double value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:dispatch.Quaternion.w)
}

// -------------------------------------------------------------------

// Pose

// .dispatch.Point position = 1;
inline bool Pose::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool Pose::has_position() const {
  return _internal_has_position();
}
inline void Pose::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::dispatch::Point& Pose::_internal_position() const {
  const ::dispatch::Point* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Point&>(
      ::dispatch::_Point_default_instance_);
}
inline const ::dispatch::Point& Pose::position() const {
  // @@protoc_insertion_point(field_get:dispatch.Pose.position)
  return _internal_position();
}
inline void Pose::unsafe_arena_set_allocated_position(
    ::dispatch::Point* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.Pose.position)
}
inline ::dispatch::Point* Pose::release_position() {
  
  ::dispatch::Point* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Point* Pose::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:dispatch.Pose.position)
  
  ::dispatch::Point* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::dispatch::Point* Pose::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Point>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::dispatch::Point* Pose::mutable_position() {
  ::dispatch::Point* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:dispatch.Pose.position)
  return _msg;
}
inline void Pose::set_allocated_position(::dispatch::Point* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:dispatch.Pose.position)
}

// .dispatch.Quaternion orientation = 2;
inline bool Pose::_internal_has_orientation() const {
  return this != internal_default_instance() && _impl_.orientation_ != nullptr;
}
inline bool Pose::has_orientation() const {
  return _internal_has_orientation();
}
inline void Pose::clear_orientation() {
  if (GetArenaForAllocation() == nullptr && _impl_.orientation_ != nullptr) {
    delete _impl_.orientation_;
  }
  _impl_.orientation_ = nullptr;
}
inline const ::dispatch::Quaternion& Pose::_internal_orientation() const {
  const ::dispatch::Quaternion* p = _impl_.orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Quaternion&>(
      ::dispatch::_Quaternion_default_instance_);
}
inline const ::dispatch::Quaternion& Pose::orientation() const {
  // @@protoc_insertion_point(field_get:dispatch.Pose.orientation)
  return _internal_orientation();
}
inline void Pose::unsafe_arena_set_allocated_orientation(
    ::dispatch::Quaternion* orientation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orientation_);
  }
  _impl_.orientation_ = orientation;
  if (orientation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.Pose.orientation)
}
inline ::dispatch::Quaternion* Pose::release_orientation() {
  
  ::dispatch::Quaternion* temp = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Quaternion* Pose::unsafe_arena_release_orientation() {
  // @@protoc_insertion_point(field_release:dispatch.Pose.orientation)
  
  ::dispatch::Quaternion* temp = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  return temp;
}
inline ::dispatch::Quaternion* Pose::_internal_mutable_orientation() {
  
  if (_impl_.orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Quaternion>(GetArenaForAllocation());
    _impl_.orientation_ = p;
  }
  return _impl_.orientation_;
}
inline ::dispatch::Quaternion* Pose::mutable_orientation() {
  ::dispatch::Quaternion* _msg = _internal_mutable_orientation();
  // @@protoc_insertion_point(field_mutable:dispatch.Pose.orientation)
  return _msg;
}
inline void Pose::set_allocated_orientation(::dispatch::Quaternion* orientation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orientation_;
  }
  if (orientation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orientation);
    if (message_arena != submessage_arena) {
      orientation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:dispatch.Pose.orientation)
}

// -------------------------------------------------------------------

// PoseStamped

// .dispatch.Header header = 1;
inline bool PoseStamped::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool PoseStamped::has_header() const {
  return _internal_has_header();
}
inline void PoseStamped::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::dispatch::Header& PoseStamped::_internal_header() const {
  const ::dispatch::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Header&>(
      ::dispatch::_Header_default_instance_);
}
inline const ::dispatch::Header& PoseStamped::header() const {
  // @@protoc_insertion_point(field_get:dispatch.PoseStamped.header)
  return _internal_header();
}
inline void PoseStamped::unsafe_arena_set_allocated_header(
    ::dispatch::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.PoseStamped.header)
}
inline ::dispatch::Header* PoseStamped::release_header() {
  
  ::dispatch::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Header* PoseStamped::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:dispatch.PoseStamped.header)
  
  ::dispatch::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::dispatch::Header* PoseStamped::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::dispatch::Header* PoseStamped::mutable_header() {
  ::dispatch::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:dispatch.PoseStamped.header)
  return _msg;
}
inline void PoseStamped::set_allocated_header(::dispatch::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:dispatch.PoseStamped.header)
}

// .dispatch.Pose pose = 2;
inline bool PoseStamped::_internal_has_pose() const {
  return this != internal_default_instance() && _impl_.pose_ != nullptr;
}
inline bool PoseStamped::has_pose() const {
  return _internal_has_pose();
}
inline void PoseStamped::clear_pose() {
  if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr) {
    delete _impl_.pose_;
  }
  _impl_.pose_ = nullptr;
}
inline const ::dispatch::Pose& PoseStamped::_internal_pose() const {
  const ::dispatch::Pose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Pose&>(
      ::dispatch::_Pose_default_instance_);
}
inline const ::dispatch::Pose& PoseStamped::pose() const {
  // @@protoc_insertion_point(field_get:dispatch.PoseStamped.pose)
  return _internal_pose();
}
inline void PoseStamped::unsafe_arena_set_allocated_pose(
    ::dispatch::Pose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.PoseStamped.pose)
}
inline ::dispatch::Pose* PoseStamped::release_pose() {
  
  ::dispatch::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Pose* PoseStamped::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:dispatch.PoseStamped.pose)
  
  ::dispatch::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::dispatch::Pose* PoseStamped::_internal_mutable_pose() {
  
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Pose>(GetArenaForAllocation());
    _impl_.pose_ = p;
  }
  return _impl_.pose_;
}
inline ::dispatch::Pose* PoseStamped::mutable_pose() {
  ::dispatch::Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:dispatch.PoseStamped.pose)
  return _msg;
}
inline void PoseStamped::set_allocated_pose(::dispatch::Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:dispatch.PoseStamped.pose)
}

// -------------------------------------------------------------------

// Path

// .dispatch.Header header = 1;
inline bool Path::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool Path::has_header() const {
  return _internal_has_header();
}
inline void Path::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::dispatch::Header& Path::_internal_header() const {
  const ::dispatch::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Header&>(
      ::dispatch::_Header_default_instance_);
}
inline const ::dispatch::Header& Path::header() const {
  // @@protoc_insertion_point(field_get:dispatch.Path.header)
  return _internal_header();
}
inline void Path::unsafe_arena_set_allocated_header(
    ::dispatch::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.Path.header)
}
inline ::dispatch::Header* Path::release_header() {
  
  ::dispatch::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Header* Path::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:dispatch.Path.header)
  
  ::dispatch::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::dispatch::Header* Path::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::dispatch::Header* Path::mutable_header() {
  ::dispatch::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:dispatch.Path.header)
  return _msg;
}
inline void Path::set_allocated_header(::dispatch::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:dispatch.Path.header)
}

// repeated .dispatch.PoseStamped pose = 2;
inline int Path::_internal_pose_size() const {
  return _impl_.pose_.size();
}
inline int Path::pose_size() const {
  return _internal_pose_size();
}
inline void Path::clear_pose() {
  _impl_.pose_.Clear();
}
inline ::dispatch::PoseStamped* Path::mutable_pose(int index) {
  // @@protoc_insertion_point(field_mutable:dispatch.Path.pose)
  return _impl_.pose_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dispatch::PoseStamped >*
Path::mutable_pose() {
  // @@protoc_insertion_point(field_mutable_list:dispatch.Path.pose)
  return &_impl_.pose_;
}
inline const ::dispatch::PoseStamped& Path::_internal_pose(int index) const {
  return _impl_.pose_.Get(index);
}
inline const ::dispatch::PoseStamped& Path::pose(int index) const {
  // @@protoc_insertion_point(field_get:dispatch.Path.pose)
  return _internal_pose(index);
}
inline ::dispatch::PoseStamped* Path::_internal_add_pose() {
  return _impl_.pose_.Add();
}
inline ::dispatch::PoseStamped* Path::add_pose() {
  ::dispatch::PoseStamped* _add = _internal_add_pose();
  // @@protoc_insertion_point(field_add:dispatch.Path.pose)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dispatch::PoseStamped >&
Path::pose() const {
  // @@protoc_insertion_point(field_list:dispatch.Path.pose)
  return _impl_.pose_;
}

// -------------------------------------------------------------------

// Vector3

// double x = 1;
inline void Vector3::clear_x() {
  _impl_.x_ = 0;
}
inline double Vector3::_internal_x() const {
  return _impl_.x_;
}
inline double Vector3::x() const {
  // @@protoc_insertion_point(field_get:dispatch.Vector3.x)
  return _internal_x();
}
inline void Vector3::_internal_set_x(double value) {
  
  _impl_.x_ = value;
}
inline void Vector3::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:dispatch.Vector3.x)
}

// double y = 2;
inline void Vector3::clear_y() {
  _impl_.y_ = 0;
}
inline double Vector3::_internal_y() const {
  return _impl_.y_;
}
inline double Vector3::y() const {
  // @@protoc_insertion_point(field_get:dispatch.Vector3.y)
  return _internal_y();
}
inline void Vector3::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void Vector3::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:dispatch.Vector3.y)
}

// double z = 3;
inline void Vector3::clear_z() {
  _impl_.z_ = 0;
}
inline double Vector3::_internal_z() const {
  return _impl_.z_;
}
inline double Vector3::z() const {
  // @@protoc_insertion_point(field_get:dispatch.Vector3.z)
  return _internal_z();
}
inline void Vector3::_internal_set_z(double value) {
  
  _impl_.z_ = value;
}
inline void Vector3::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:dispatch.Vector3.z)
}

// -------------------------------------------------------------------

// Twist

// .dispatch.Vector3 linear = 1;
inline bool Twist::_internal_has_linear() const {
  return this != internal_default_instance() && _impl_.linear_ != nullptr;
}
inline bool Twist::has_linear() const {
  return _internal_has_linear();
}
inline void Twist::clear_linear() {
  if (GetArenaForAllocation() == nullptr && _impl_.linear_ != nullptr) {
    delete _impl_.linear_;
  }
  _impl_.linear_ = nullptr;
}
inline const ::dispatch::Vector3& Twist::_internal_linear() const {
  const ::dispatch::Vector3* p = _impl_.linear_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Vector3&>(
      ::dispatch::_Vector3_default_instance_);
}
inline const ::dispatch::Vector3& Twist::linear() const {
  // @@protoc_insertion_point(field_get:dispatch.Twist.linear)
  return _internal_linear();
}
inline void Twist::unsafe_arena_set_allocated_linear(
    ::dispatch::Vector3* linear) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_);
  }
  _impl_.linear_ = linear;
  if (linear) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.Twist.linear)
}
inline ::dispatch::Vector3* Twist::release_linear() {
  
  ::dispatch::Vector3* temp = _impl_.linear_;
  _impl_.linear_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Vector3* Twist::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_release:dispatch.Twist.linear)
  
  ::dispatch::Vector3* temp = _impl_.linear_;
  _impl_.linear_ = nullptr;
  return temp;
}
inline ::dispatch::Vector3* Twist::_internal_mutable_linear() {
  
  if (_impl_.linear_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Vector3>(GetArenaForAllocation());
    _impl_.linear_ = p;
  }
  return _impl_.linear_;
}
inline ::dispatch::Vector3* Twist::mutable_linear() {
  ::dispatch::Vector3* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:dispatch.Twist.linear)
  return _msg;
}
inline void Twist::set_allocated_linear(::dispatch::Vector3* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_;
  }
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linear_ = linear;
  // @@protoc_insertion_point(field_set_allocated:dispatch.Twist.linear)
}

// .dispatch.Vector3 angular = 2;
inline bool Twist::_internal_has_angular() const {
  return this != internal_default_instance() && _impl_.angular_ != nullptr;
}
inline bool Twist::has_angular() const {
  return _internal_has_angular();
}
inline void Twist::clear_angular() {
  if (GetArenaForAllocation() == nullptr && _impl_.angular_ != nullptr) {
    delete _impl_.angular_;
  }
  _impl_.angular_ = nullptr;
}
inline const ::dispatch::Vector3& Twist::_internal_angular() const {
  const ::dispatch::Vector3* p = _impl_.angular_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Vector3&>(
      ::dispatch::_Vector3_default_instance_);
}
inline const ::dispatch::Vector3& Twist::angular() const {
  // @@protoc_insertion_point(field_get:dispatch.Twist.angular)
  return _internal_angular();
}
inline void Twist::unsafe_arena_set_allocated_angular(
    ::dispatch::Vector3* angular) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angular_);
  }
  _impl_.angular_ = angular;
  if (angular) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.Twist.angular)
}
inline ::dispatch::Vector3* Twist::release_angular() {
  
  ::dispatch::Vector3* temp = _impl_.angular_;
  _impl_.angular_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Vector3* Twist::unsafe_arena_release_angular() {
  // @@protoc_insertion_point(field_release:dispatch.Twist.angular)
  
  ::dispatch::Vector3* temp = _impl_.angular_;
  _impl_.angular_ = nullptr;
  return temp;
}
inline ::dispatch::Vector3* Twist::_internal_mutable_angular() {
  
  if (_impl_.angular_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Vector3>(GetArenaForAllocation());
    _impl_.angular_ = p;
  }
  return _impl_.angular_;
}
inline ::dispatch::Vector3* Twist::mutable_angular() {
  ::dispatch::Vector3* _msg = _internal_mutable_angular();
  // @@protoc_insertion_point(field_mutable:dispatch.Twist.angular)
  return _msg;
}
inline void Twist::set_allocated_angular(::dispatch::Vector3* angular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.angular_;
  }
  if (angular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(angular);
    if (message_arena != submessage_arena) {
      angular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.angular_ = angular;
  // @@protoc_insertion_point(field_set_allocated:dispatch.Twist.angular)
}

// -------------------------------------------------------------------

// Current_pose

// .dispatch.Pose pose = 1;
inline bool Current_pose::_internal_has_pose() const {
  return this != internal_default_instance() && _impl_.pose_ != nullptr;
}
inline bool Current_pose::has_pose() const {
  return _internal_has_pose();
}
inline void Current_pose::clear_pose() {
  if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr) {
    delete _impl_.pose_;
  }
  _impl_.pose_ = nullptr;
}
inline const ::dispatch::Pose& Current_pose::_internal_pose() const {
  const ::dispatch::Pose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Pose&>(
      ::dispatch::_Pose_default_instance_);
}
inline const ::dispatch::Pose& Current_pose::pose() const {
  // @@protoc_insertion_point(field_get:dispatch.Current_pose.pose)
  return _internal_pose();
}
inline void Current_pose::unsafe_arena_set_allocated_pose(
    ::dispatch::Pose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.Current_pose.pose)
}
inline ::dispatch::Pose* Current_pose::release_pose() {
  
  ::dispatch::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Pose* Current_pose::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:dispatch.Current_pose.pose)
  
  ::dispatch::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::dispatch::Pose* Current_pose::_internal_mutable_pose() {
  
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Pose>(GetArenaForAllocation());
    _impl_.pose_ = p;
  }
  return _impl_.pose_;
}
inline ::dispatch::Pose* Current_pose::mutable_pose() {
  ::dispatch::Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:dispatch.Current_pose.pose)
  return _msg;
}
inline void Current_pose::set_allocated_pose(::dispatch::Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:dispatch.Current_pose.pose)
}

// -------------------------------------------------------------------

// Current_twist

// .dispatch.Twist twist = 1;
inline bool Current_twist::_internal_has_twist() const {
  return this != internal_default_instance() && _impl_.twist_ != nullptr;
}
inline bool Current_twist::has_twist() const {
  return _internal_has_twist();
}
inline void Current_twist::clear_twist() {
  if (GetArenaForAllocation() == nullptr && _impl_.twist_ != nullptr) {
    delete _impl_.twist_;
  }
  _impl_.twist_ = nullptr;
}
inline const ::dispatch::Twist& Current_twist::_internal_twist() const {
  const ::dispatch::Twist* p = _impl_.twist_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Twist&>(
      ::dispatch::_Twist_default_instance_);
}
inline const ::dispatch::Twist& Current_twist::twist() const {
  // @@protoc_insertion_point(field_get:dispatch.Current_twist.twist)
  return _internal_twist();
}
inline void Current_twist::unsafe_arena_set_allocated_twist(
    ::dispatch::Twist* twist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.twist_);
  }
  _impl_.twist_ = twist;
  if (twist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.Current_twist.twist)
}
inline ::dispatch::Twist* Current_twist::release_twist() {
  
  ::dispatch::Twist* temp = _impl_.twist_;
  _impl_.twist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Twist* Current_twist::unsafe_arena_release_twist() {
  // @@protoc_insertion_point(field_release:dispatch.Current_twist.twist)
  
  ::dispatch::Twist* temp = _impl_.twist_;
  _impl_.twist_ = nullptr;
  return temp;
}
inline ::dispatch::Twist* Current_twist::_internal_mutable_twist() {
  
  if (_impl_.twist_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Twist>(GetArenaForAllocation());
    _impl_.twist_ = p;
  }
  return _impl_.twist_;
}
inline ::dispatch::Twist* Current_twist::mutable_twist() {
  ::dispatch::Twist* _msg = _internal_mutable_twist();
  // @@protoc_insertion_point(field_mutable:dispatch.Current_twist.twist)
  return _msg;
}
inline void Current_twist::set_allocated_twist(::dispatch::Twist* twist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.twist_;
  }
  if (twist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(twist);
    if (message_arena != submessage_arena) {
      twist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, twist, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.twist_ = twist;
  // @@protoc_insertion_point(field_set_allocated:dispatch.Current_twist.twist)
}

// -------------------------------------------------------------------

// Goal_pose

// .dispatch.Pose pose = 1;
inline bool Goal_pose::_internal_has_pose() const {
  return this != internal_default_instance() && _impl_.pose_ != nullptr;
}
inline bool Goal_pose::has_pose() const {
  return _internal_has_pose();
}
inline void Goal_pose::clear_pose() {
  if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr) {
    delete _impl_.pose_;
  }
  _impl_.pose_ = nullptr;
}
inline const ::dispatch::Pose& Goal_pose::_internal_pose() const {
  const ::dispatch::Pose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Pose&>(
      ::dispatch::_Pose_default_instance_);
}
inline const ::dispatch::Pose& Goal_pose::pose() const {
  // @@protoc_insertion_point(field_get:dispatch.Goal_pose.pose)
  return _internal_pose();
}
inline void Goal_pose::unsafe_arena_set_allocated_pose(
    ::dispatch::Pose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.Goal_pose.pose)
}
inline ::dispatch::Pose* Goal_pose::release_pose() {
  
  ::dispatch::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Pose* Goal_pose::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:dispatch.Goal_pose.pose)
  
  ::dispatch::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::dispatch::Pose* Goal_pose::_internal_mutable_pose() {
  
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Pose>(GetArenaForAllocation());
    _impl_.pose_ = p;
  }
  return _impl_.pose_;
}
inline ::dispatch::Pose* Goal_pose::mutable_pose() {
  ::dispatch::Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:dispatch.Goal_pose.pose)
  return _msg;
}
inline void Goal_pose::set_allocated_pose(::dispatch::Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:dispatch.Goal_pose.pose)
}

// -------------------------------------------------------------------

// Current_path

// repeated .dispatch.Pose pose = 1;
inline int Current_path::_internal_pose_size() const {
  return _impl_.pose_.size();
}
inline int Current_path::pose_size() const {
  return _internal_pose_size();
}
inline void Current_path::clear_pose() {
  _impl_.pose_.Clear();
}
inline ::dispatch::Pose* Current_path::mutable_pose(int index) {
  // @@protoc_insertion_point(field_mutable:dispatch.Current_path.pose)
  return _impl_.pose_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dispatch::Pose >*
Current_path::mutable_pose() {
  // @@protoc_insertion_point(field_mutable_list:dispatch.Current_path.pose)
  return &_impl_.pose_;
}
inline const ::dispatch::Pose& Current_path::_internal_pose(int index) const {
  return _impl_.pose_.Get(index);
}
inline const ::dispatch::Pose& Current_path::pose(int index) const {
  // @@protoc_insertion_point(field_get:dispatch.Current_path.pose)
  return _internal_pose(index);
}
inline ::dispatch::Pose* Current_path::_internal_add_pose() {
  return _impl_.pose_.Add();
}
inline ::dispatch::Pose* Current_path::add_pose() {
  ::dispatch::Pose* _add = _internal_add_pose();
  // @@protoc_insertion_point(field_add:dispatch.Current_path.pose)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dispatch::Pose >&
Current_path::pose() const {
  // @@protoc_insertion_point(field_list:dispatch.Current_path.pose)
  return _impl_.pose_;
}

// -------------------------------------------------------------------

// Goal_twist

// .dispatch.Twist twist = 1;
inline bool Goal_twist::_internal_has_twist() const {
  return this != internal_default_instance() && _impl_.twist_ != nullptr;
}
inline bool Goal_twist::has_twist() const {
  return _internal_has_twist();
}
inline void Goal_twist::clear_twist() {
  if (GetArenaForAllocation() == nullptr && _impl_.twist_ != nullptr) {
    delete _impl_.twist_;
  }
  _impl_.twist_ = nullptr;
}
inline const ::dispatch::Twist& Goal_twist::_internal_twist() const {
  const ::dispatch::Twist* p = _impl_.twist_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Twist&>(
      ::dispatch::_Twist_default_instance_);
}
inline const ::dispatch::Twist& Goal_twist::twist() const {
  // @@protoc_insertion_point(field_get:dispatch.Goal_twist.twist)
  return _internal_twist();
}
inline void Goal_twist::unsafe_arena_set_allocated_twist(
    ::dispatch::Twist* twist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.twist_);
  }
  _impl_.twist_ = twist;
  if (twist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.Goal_twist.twist)
}
inline ::dispatch::Twist* Goal_twist::release_twist() {
  
  ::dispatch::Twist* temp = _impl_.twist_;
  _impl_.twist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Twist* Goal_twist::unsafe_arena_release_twist() {
  // @@protoc_insertion_point(field_release:dispatch.Goal_twist.twist)
  
  ::dispatch::Twist* temp = _impl_.twist_;
  _impl_.twist_ = nullptr;
  return temp;
}
inline ::dispatch::Twist* Goal_twist::_internal_mutable_twist() {
  
  if (_impl_.twist_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Twist>(GetArenaForAllocation());
    _impl_.twist_ = p;
  }
  return _impl_.twist_;
}
inline ::dispatch::Twist* Goal_twist::mutable_twist() {
  ::dispatch::Twist* _msg = _internal_mutable_twist();
  // @@protoc_insertion_point(field_mutable:dispatch.Goal_twist.twist)
  return _msg;
}
inline void Goal_twist::set_allocated_twist(::dispatch::Twist* twist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.twist_;
  }
  if (twist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(twist);
    if (message_arena != submessage_arena) {
      twist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, twist, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.twist_ = twist;
  // @@protoc_insertion_point(field_set_allocated:dispatch.Goal_twist.twist)
}

// -------------------------------------------------------------------

// Multiple_goal

// repeated .dispatch.PoseStamped pose = 1;
inline int Multiple_goal::_internal_pose_size() const {
  return _impl_.pose_.size();
}
inline int Multiple_goal::pose_size() const {
  return _internal_pose_size();
}
inline void Multiple_goal::clear_pose() {
  _impl_.pose_.Clear();
}
inline ::dispatch::PoseStamped* Multiple_goal::mutable_pose(int index) {
  // @@protoc_insertion_point(field_mutable:dispatch.Multiple_goal.pose)
  return _impl_.pose_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dispatch::PoseStamped >*
Multiple_goal::mutable_pose() {
  // @@protoc_insertion_point(field_mutable_list:dispatch.Multiple_goal.pose)
  return &_impl_.pose_;
}
inline const ::dispatch::PoseStamped& Multiple_goal::_internal_pose(int index) const {
  return _impl_.pose_.Get(index);
}
inline const ::dispatch::PoseStamped& Multiple_goal::pose(int index) const {
  // @@protoc_insertion_point(field_get:dispatch.Multiple_goal.pose)
  return _internal_pose(index);
}
inline ::dispatch::PoseStamped* Multiple_goal::_internal_add_pose() {
  return _impl_.pose_.Add();
}
inline ::dispatch::PoseStamped* Multiple_goal::add_pose() {
  ::dispatch::PoseStamped* _add = _internal_add_pose();
  // @@protoc_insertion_point(field_add:dispatch.Multiple_goal.pose)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dispatch::PoseStamped >&
Multiple_goal::pose() const {
  // @@protoc_insertion_point(field_list:dispatch.Multiple_goal.pose)
  return _impl_.pose_;
}

// -------------------------------------------------------------------

// MsgHeader

// uint64 timestamp = 1;
inline void MsgHeader::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t MsgHeader::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t MsgHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:dispatch.MsgHeader.timestamp)
  return _internal_timestamp();
}
inline void MsgHeader::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void MsgHeader::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:dispatch.MsgHeader.timestamp)
}

// uint32 msg_id = 2;
inline void MsgHeader::clear_msg_id() {
  _impl_.msg_id_ = 0u;
}
inline uint32_t MsgHeader::_internal_msg_id() const {
  return _impl_.msg_id_;
}
inline uint32_t MsgHeader::msg_id() const {
  // @@protoc_insertion_point(field_get:dispatch.MsgHeader.msg_id)
  return _internal_msg_id();
}
inline void MsgHeader::_internal_set_msg_id(uint32_t value) {
  
  _impl_.msg_id_ = value;
}
inline void MsgHeader::set_msg_id(uint32_t value) {
  _internal_set_msg_id(value);
  // @@protoc_insertion_point(field_set:dispatch.MsgHeader.msg_id)
}

// -------------------------------------------------------------------

// VehicleInfo

// .dispatch.MsgHeader header = 1;
inline bool VehicleInfo::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool VehicleInfo::has_header() const {
  return _internal_has_header();
}
inline void VehicleInfo::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::dispatch::MsgHeader& VehicleInfo::_internal_header() const {
  const ::dispatch::MsgHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::MsgHeader&>(
      ::dispatch::_MsgHeader_default_instance_);
}
inline const ::dispatch::MsgHeader& VehicleInfo::header() const {
  // @@protoc_insertion_point(field_get:dispatch.VehicleInfo.header)
  return _internal_header();
}
inline void VehicleInfo::unsafe_arena_set_allocated_header(
    ::dispatch::MsgHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.VehicleInfo.header)
}
inline ::dispatch::MsgHeader* VehicleInfo::release_header() {
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::MsgHeader* VehicleInfo::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:dispatch.VehicleInfo.header)
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::dispatch::MsgHeader* VehicleInfo::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::MsgHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::dispatch::MsgHeader* VehicleInfo::mutable_header() {
  ::dispatch::MsgHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:dispatch.VehicleInfo.header)
  return _msg;
}
inline void VehicleInfo::set_allocated_header(::dispatch::MsgHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:dispatch.VehicleInfo.header)
}

// .dispatch.Pose pose = 2;
inline bool VehicleInfo::_internal_has_pose() const {
  return this != internal_default_instance() && _impl_.pose_ != nullptr;
}
inline bool VehicleInfo::has_pose() const {
  return _internal_has_pose();
}
inline void VehicleInfo::clear_pose() {
  if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr) {
    delete _impl_.pose_;
  }
  _impl_.pose_ = nullptr;
}
inline const ::dispatch::Pose& VehicleInfo::_internal_pose() const {
  const ::dispatch::Pose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Pose&>(
      ::dispatch::_Pose_default_instance_);
}
inline const ::dispatch::Pose& VehicleInfo::pose() const {
  // @@protoc_insertion_point(field_get:dispatch.VehicleInfo.pose)
  return _internal_pose();
}
inline void VehicleInfo::unsafe_arena_set_allocated_pose(
    ::dispatch::Pose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.VehicleInfo.pose)
}
inline ::dispatch::Pose* VehicleInfo::release_pose() {
  
  ::dispatch::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Pose* VehicleInfo::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:dispatch.VehicleInfo.pose)
  
  ::dispatch::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::dispatch::Pose* VehicleInfo::_internal_mutable_pose() {
  
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Pose>(GetArenaForAllocation());
    _impl_.pose_ = p;
  }
  return _impl_.pose_;
}
inline ::dispatch::Pose* VehicleInfo::mutable_pose() {
  ::dispatch::Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:dispatch.VehicleInfo.pose)
  return _msg;
}
inline void VehicleInfo::set_allocated_pose(::dispatch::Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:dispatch.VehicleInfo.pose)
}

// .dispatch.Twist twist = 3;
inline bool VehicleInfo::_internal_has_twist() const {
  return this != internal_default_instance() && _impl_.twist_ != nullptr;
}
inline bool VehicleInfo::has_twist() const {
  return _internal_has_twist();
}
inline void VehicleInfo::clear_twist() {
  if (GetArenaForAllocation() == nullptr && _impl_.twist_ != nullptr) {
    delete _impl_.twist_;
  }
  _impl_.twist_ = nullptr;
}
inline const ::dispatch::Twist& VehicleInfo::_internal_twist() const {
  const ::dispatch::Twist* p = _impl_.twist_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Twist&>(
      ::dispatch::_Twist_default_instance_);
}
inline const ::dispatch::Twist& VehicleInfo::twist() const {
  // @@protoc_insertion_point(field_get:dispatch.VehicleInfo.twist)
  return _internal_twist();
}
inline void VehicleInfo::unsafe_arena_set_allocated_twist(
    ::dispatch::Twist* twist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.twist_);
  }
  _impl_.twist_ = twist;
  if (twist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.VehicleInfo.twist)
}
inline ::dispatch::Twist* VehicleInfo::release_twist() {
  
  ::dispatch::Twist* temp = _impl_.twist_;
  _impl_.twist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Twist* VehicleInfo::unsafe_arena_release_twist() {
  // @@protoc_insertion_point(field_release:dispatch.VehicleInfo.twist)
  
  ::dispatch::Twist* temp = _impl_.twist_;
  _impl_.twist_ = nullptr;
  return temp;
}
inline ::dispatch::Twist* VehicleInfo::_internal_mutable_twist() {
  
  if (_impl_.twist_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Twist>(GetArenaForAllocation());
    _impl_.twist_ = p;
  }
  return _impl_.twist_;
}
inline ::dispatch::Twist* VehicleInfo::mutable_twist() {
  ::dispatch::Twist* _msg = _internal_mutable_twist();
  // @@protoc_insertion_point(field_mutable:dispatch.VehicleInfo.twist)
  return _msg;
}
inline void VehicleInfo::set_allocated_twist(::dispatch::Twist* twist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.twist_;
  }
  if (twist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(twist);
    if (message_arena != submessage_arena) {
      twist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, twist, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.twist_ = twist;
  // @@protoc_insertion_point(field_set_allocated:dispatch.VehicleInfo.twist)
}

// .dispatch.VehicleMotionState motion = 4;
inline void VehicleInfo::clear_motion() {
  _impl_.motion_ = 0;
}
inline ::dispatch::VehicleMotionState VehicleInfo::_internal_motion() const {
  return static_cast< ::dispatch::VehicleMotionState >(_impl_.motion_);
}
inline ::dispatch::VehicleMotionState VehicleInfo::motion() const {
  // @@protoc_insertion_point(field_get:dispatch.VehicleInfo.motion)
  return _internal_motion();
}
inline void VehicleInfo::_internal_set_motion(::dispatch::VehicleMotionState value) {
  
  _impl_.motion_ = value;
}
inline void VehicleInfo::set_motion(::dispatch::VehicleMotionState value) {
  _internal_set_motion(value);
  // @@protoc_insertion_point(field_set:dispatch.VehicleInfo.motion)
}

// .dispatch.DrivingMode driving_mode = 5;
inline void VehicleInfo::clear_driving_mode() {
  _impl_.driving_mode_ = 0;
}
inline ::dispatch::DrivingMode VehicleInfo::_internal_driving_mode() const {
  return static_cast< ::dispatch::DrivingMode >(_impl_.driving_mode_);
}
inline ::dispatch::DrivingMode VehicleInfo::driving_mode() const {
  // @@protoc_insertion_point(field_get:dispatch.VehicleInfo.driving_mode)
  return _internal_driving_mode();
}
inline void VehicleInfo::_internal_set_driving_mode(::dispatch::DrivingMode value) {
  
  _impl_.driving_mode_ = value;
}
inline void VehicleInfo::set_driving_mode(::dispatch::DrivingMode value) {
  _internal_set_driving_mode(value);
  // @@protoc_insertion_point(field_set:dispatch.VehicleInfo.driving_mode)
}

// -------------------------------------------------------------------

// ActionRequest

// .dispatch.MsgHeader header = 1;
inline bool ActionRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ActionRequest::has_header() const {
  return _internal_has_header();
}
inline void ActionRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::dispatch::MsgHeader& ActionRequest::_internal_header() const {
  const ::dispatch::MsgHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::MsgHeader&>(
      ::dispatch::_MsgHeader_default_instance_);
}
inline const ::dispatch::MsgHeader& ActionRequest::header() const {
  // @@protoc_insertion_point(field_get:dispatch.ActionRequest.header)
  return _internal_header();
}
inline void ActionRequest::unsafe_arena_set_allocated_header(
    ::dispatch::MsgHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.ActionRequest.header)
}
inline ::dispatch::MsgHeader* ActionRequest::release_header() {
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::MsgHeader* ActionRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:dispatch.ActionRequest.header)
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::dispatch::MsgHeader* ActionRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::MsgHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::dispatch::MsgHeader* ActionRequest::mutable_header() {
  ::dispatch::MsgHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:dispatch.ActionRequest.header)
  return _msg;
}
inline void ActionRequest::set_allocated_header(::dispatch::MsgHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:dispatch.ActionRequest.header)
}

// .dispatch.ActionType action_type = 2;
inline void ActionRequest::clear_action_type() {
  _impl_.action_type_ = 0;
}
inline ::dispatch::ActionType ActionRequest::_internal_action_type() const {
  return static_cast< ::dispatch::ActionType >(_impl_.action_type_);
}
inline ::dispatch::ActionType ActionRequest::action_type() const {
  // @@protoc_insertion_point(field_get:dispatch.ActionRequest.action_type)
  return _internal_action_type();
}
inline void ActionRequest::_internal_set_action_type(::dispatch::ActionType value) {
  
  _impl_.action_type_ = value;
}
inline void ActionRequest::set_action_type(::dispatch::ActionType value) {
  _internal_set_action_type(value);
  // @@protoc_insertion_point(field_set:dispatch.ActionRequest.action_type)
}

// .dispatch.Current_path path = 3;
inline bool ActionRequest::_internal_has_path() const {
  return this != internal_default_instance() && _impl_.path_ != nullptr;
}
inline bool ActionRequest::has_path() const {
  return _internal_has_path();
}
inline void ActionRequest::clear_path() {
  if (GetArenaForAllocation() == nullptr && _impl_.path_ != nullptr) {
    delete _impl_.path_;
  }
  _impl_.path_ = nullptr;
}
inline const ::dispatch::Current_path& ActionRequest::_internal_path() const {
  const ::dispatch::Current_path* p = _impl_.path_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Current_path&>(
      ::dispatch::_Current_path_default_instance_);
}
inline const ::dispatch::Current_path& ActionRequest::path() const {
  // @@protoc_insertion_point(field_get:dispatch.ActionRequest.path)
  return _internal_path();
}
inline void ActionRequest::unsafe_arena_set_allocated_path(
    ::dispatch::Current_path* path) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.path_);
  }
  _impl_.path_ = path;
  if (path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.ActionRequest.path)
}
inline ::dispatch::Current_path* ActionRequest::release_path() {
  
  ::dispatch::Current_path* temp = _impl_.path_;
  _impl_.path_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Current_path* ActionRequest::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_release:dispatch.ActionRequest.path)
  
  ::dispatch::Current_path* temp = _impl_.path_;
  _impl_.path_ = nullptr;
  return temp;
}
inline ::dispatch::Current_path* ActionRequest::_internal_mutable_path() {
  
  if (_impl_.path_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Current_path>(GetArenaForAllocation());
    _impl_.path_ = p;
  }
  return _impl_.path_;
}
inline ::dispatch::Current_path* ActionRequest::mutable_path() {
  ::dispatch::Current_path* _msg = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:dispatch.ActionRequest.path)
  return _msg;
}
inline void ActionRequest::set_allocated_path(::dispatch::Current_path* path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.path_;
  }
  if (path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(path);
    if (message_arena != submessage_arena) {
      path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.path_ = path;
  // @@protoc_insertion_point(field_set_allocated:dispatch.ActionRequest.path)
}

// .dispatch.Goal_pose goal = 4;
inline bool ActionRequest::_internal_has_goal() const {
  return this != internal_default_instance() && _impl_.goal_ != nullptr;
}
inline bool ActionRequest::has_goal() const {
  return _internal_has_goal();
}
inline void ActionRequest::clear_goal() {
  if (GetArenaForAllocation() == nullptr && _impl_.goal_ != nullptr) {
    delete _impl_.goal_;
  }
  _impl_.goal_ = nullptr;
}
inline const ::dispatch::Goal_pose& ActionRequest::_internal_goal() const {
  const ::dispatch::Goal_pose* p = _impl_.goal_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::Goal_pose&>(
      ::dispatch::_Goal_pose_default_instance_);
}
inline const ::dispatch::Goal_pose& ActionRequest::goal() const {
  // @@protoc_insertion_point(field_get:dispatch.ActionRequest.goal)
  return _internal_goal();
}
inline void ActionRequest::unsafe_arena_set_allocated_goal(
    ::dispatch::Goal_pose* goal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.goal_);
  }
  _impl_.goal_ = goal;
  if (goal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.ActionRequest.goal)
}
inline ::dispatch::Goal_pose* ActionRequest::release_goal() {
  
  ::dispatch::Goal_pose* temp = _impl_.goal_;
  _impl_.goal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::Goal_pose* ActionRequest::unsafe_arena_release_goal() {
  // @@protoc_insertion_point(field_release:dispatch.ActionRequest.goal)
  
  ::dispatch::Goal_pose* temp = _impl_.goal_;
  _impl_.goal_ = nullptr;
  return temp;
}
inline ::dispatch::Goal_pose* ActionRequest::_internal_mutable_goal() {
  
  if (_impl_.goal_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::Goal_pose>(GetArenaForAllocation());
    _impl_.goal_ = p;
  }
  return _impl_.goal_;
}
inline ::dispatch::Goal_pose* ActionRequest::mutable_goal() {
  ::dispatch::Goal_pose* _msg = _internal_mutable_goal();
  // @@protoc_insertion_point(field_mutable:dispatch.ActionRequest.goal)
  return _msg;
}
inline void ActionRequest::set_allocated_goal(::dispatch::Goal_pose* goal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.goal_;
  }
  if (goal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(goal);
    if (message_arena != submessage_arena) {
      goal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, goal, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.goal_ = goal;
  // @@protoc_insertion_point(field_set_allocated:dispatch.ActionRequest.goal)
}

// uint32 park_id = 5;
inline void ActionRequest::clear_park_id() {
  _impl_.park_id_ = 0u;
}
inline uint32_t ActionRequest::_internal_park_id() const {
  return _impl_.park_id_;
}
inline uint32_t ActionRequest::park_id() const {
  // @@protoc_insertion_point(field_get:dispatch.ActionRequest.park_id)
  return _internal_park_id();
}
inline void ActionRequest::_internal_set_park_id(uint32_t value) {
  
  _impl_.park_id_ = value;
}
inline void ActionRequest::set_park_id(uint32_t value) {
  _internal_set_park_id(value);
  // @@protoc_insertion_point(field_set:dispatch.ActionRequest.park_id)
}

// -------------------------------------------------------------------

// ActionResponse

// .dispatch.MsgHeader header = 1;
inline bool ActionResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ActionResponse::has_header() const {
  return _internal_has_header();
}
inline void ActionResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::dispatch::MsgHeader& ActionResponse::_internal_header() const {
  const ::dispatch::MsgHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::MsgHeader&>(
      ::dispatch::_MsgHeader_default_instance_);
}
inline const ::dispatch::MsgHeader& ActionResponse::header() const {
  // @@protoc_insertion_point(field_get:dispatch.ActionResponse.header)
  return _internal_header();
}
inline void ActionResponse::unsafe_arena_set_allocated_header(
    ::dispatch::MsgHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.ActionResponse.header)
}
inline ::dispatch::MsgHeader* ActionResponse::release_header() {
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::MsgHeader* ActionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:dispatch.ActionResponse.header)
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::dispatch::MsgHeader* ActionResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::MsgHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::dispatch::MsgHeader* ActionResponse::mutable_header() {
  ::dispatch::MsgHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:dispatch.ActionResponse.header)
  return _msg;
}
inline void ActionResponse::set_allocated_header(::dispatch::MsgHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:dispatch.ActionResponse.header)
}

// int32 error_code = 2;
inline void ActionResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t ActionResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t ActionResponse::error_code() const {
  // @@protoc_insertion_point(field_get:dispatch.ActionResponse.error_code)
  return _internal_error_code();
}
inline void ActionResponse::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void ActionResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:dispatch.ActionResponse.error_code)
}

// string error_msg = 3;
inline void ActionResponse::clear_error_msg() {
  _impl_.error_msg_.ClearToEmpty();
}
inline const std::string& ActionResponse::error_msg() const {
  // @@protoc_insertion_point(field_get:dispatch.ActionResponse.error_msg)
  return _internal_error_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionResponse::set_error_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dispatch.ActionResponse.error_msg)
}
inline std::string* ActionResponse::mutable_error_msg() {
  std::string* _s = _internal_mutable_error_msg();
  // @@protoc_insertion_point(field_mutable:dispatch.ActionResponse.error_msg)
  return _s;
}
inline const std::string& ActionResponse::_internal_error_msg() const {
  return _impl_.error_msg_.Get();
}
inline void ActionResponse::_internal_set_error_msg(const std::string& value) {
  
  _impl_.error_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionResponse::_internal_mutable_error_msg() {
  
  return _impl_.error_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionResponse::release_error_msg() {
  // @@protoc_insertion_point(field_release:dispatch.ActionResponse.error_msg)
  return _impl_.error_msg_.Release();
}
inline void ActionResponse::set_allocated_error_msg(std::string* error_msg) {
  if (error_msg != nullptr) {
    
  } else {
    
  }
  _impl_.error_msg_.SetAllocated(error_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_msg_.IsDefault()) {
    _impl_.error_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dispatch.ActionResponse.error_msg)
}

// -------------------------------------------------------------------

// TaskRequest

// .dispatch.MsgHeader header = 1;
inline bool TaskRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool TaskRequest::has_header() const {
  return _internal_has_header();
}
inline void TaskRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::dispatch::MsgHeader& TaskRequest::_internal_header() const {
  const ::dispatch::MsgHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::MsgHeader&>(
      ::dispatch::_MsgHeader_default_instance_);
}
inline const ::dispatch::MsgHeader& TaskRequest::header() const {
  // @@protoc_insertion_point(field_get:dispatch.TaskRequest.header)
  return _internal_header();
}
inline void TaskRequest::unsafe_arena_set_allocated_header(
    ::dispatch::MsgHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.TaskRequest.header)
}
inline ::dispatch::MsgHeader* TaskRequest::release_header() {
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::MsgHeader* TaskRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:dispatch.TaskRequest.header)
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::dispatch::MsgHeader* TaskRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::MsgHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::dispatch::MsgHeader* TaskRequest::mutable_header() {
  ::dispatch::MsgHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:dispatch.TaskRequest.header)
  return _msg;
}
inline void TaskRequest::set_allocated_header(::dispatch::MsgHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:dispatch.TaskRequest.header)
}

// .dispatch.TaskType task_type = 2;
inline void TaskRequest::clear_task_type() {
  _impl_.task_type_ = 0;
}
inline ::dispatch::TaskType TaskRequest::_internal_task_type() const {
  return static_cast< ::dispatch::TaskType >(_impl_.task_type_);
}
inline ::dispatch::TaskType TaskRequest::task_type() const {
  // @@protoc_insertion_point(field_get:dispatch.TaskRequest.task_type)
  return _internal_task_type();
}
inline void TaskRequest::_internal_set_task_type(::dispatch::TaskType value) {
  
  _impl_.task_type_ = value;
}
inline void TaskRequest::set_task_type(::dispatch::TaskType value) {
  _internal_set_task_type(value);
  // @@protoc_insertion_point(field_set:dispatch.TaskRequest.task_type)
}

// uint32 area_id = 3;
inline void TaskRequest::clear_area_id() {
  _impl_.area_id_ = 0u;
}
inline uint32_t TaskRequest::_internal_area_id() const {
  return _impl_.area_id_;
}
inline uint32_t TaskRequest::area_id() const {
  // @@protoc_insertion_point(field_get:dispatch.TaskRequest.area_id)
  return _internal_area_id();
}
inline void TaskRequest::_internal_set_area_id(uint32_t value) {
  
  _impl_.area_id_ = value;
}
inline void TaskRequest::set_area_id(uint32_t value) {
  _internal_set_area_id(value);
  // @@protoc_insertion_point(field_set:dispatch.TaskRequest.area_id)
}

// -------------------------------------------------------------------

// TaskResult

// .dispatch.MsgHeader header = 1;
inline bool TaskResult::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool TaskResult::has_header() const {
  return _internal_has_header();
}
inline void TaskResult::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::dispatch::MsgHeader& TaskResult::_internal_header() const {
  const ::dispatch::MsgHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::MsgHeader&>(
      ::dispatch::_MsgHeader_default_instance_);
}
inline const ::dispatch::MsgHeader& TaskResult::header() const {
  // @@protoc_insertion_point(field_get:dispatch.TaskResult.header)
  return _internal_header();
}
inline void TaskResult::unsafe_arena_set_allocated_header(
    ::dispatch::MsgHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.TaskResult.header)
}
inline ::dispatch::MsgHeader* TaskResult::release_header() {
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::MsgHeader* TaskResult::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:dispatch.TaskResult.header)
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::dispatch::MsgHeader* TaskResult::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::MsgHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::dispatch::MsgHeader* TaskResult::mutable_header() {
  ::dispatch::MsgHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:dispatch.TaskResult.header)
  return _msg;
}
inline void TaskResult::set_allocated_header(::dispatch::MsgHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:dispatch.TaskResult.header)
}

// .dispatch.TaskType task_type = 2;
inline void TaskResult::clear_task_type() {
  _impl_.task_type_ = 0;
}
inline ::dispatch::TaskType TaskResult::_internal_task_type() const {
  return static_cast< ::dispatch::TaskType >(_impl_.task_type_);
}
inline ::dispatch::TaskType TaskResult::task_type() const {
  // @@protoc_insertion_point(field_get:dispatch.TaskResult.task_type)
  return _internal_task_type();
}
inline void TaskResult::_internal_set_task_type(::dispatch::TaskType value) {
  
  _impl_.task_type_ = value;
}
inline void TaskResult::set_task_type(::dispatch::TaskType value) {
  _internal_set_task_type(value);
  // @@protoc_insertion_point(field_set:dispatch.TaskResult.task_type)
}

// int32 error_code = 3;
inline void TaskResult::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t TaskResult::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t TaskResult::error_code() const {
  // @@protoc_insertion_point(field_get:dispatch.TaskResult.error_code)
  return _internal_error_code();
}
inline void TaskResult::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void TaskResult::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:dispatch.TaskResult.error_code)
}

// string error_msg = 4;
inline void TaskResult::clear_error_msg() {
  _impl_.error_msg_.ClearToEmpty();
}
inline const std::string& TaskResult::error_msg() const {
  // @@protoc_insertion_point(field_get:dispatch.TaskResult.error_msg)
  return _internal_error_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskResult::set_error_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dispatch.TaskResult.error_msg)
}
inline std::string* TaskResult::mutable_error_msg() {
  std::string* _s = _internal_mutable_error_msg();
  // @@protoc_insertion_point(field_mutable:dispatch.TaskResult.error_msg)
  return _s;
}
inline const std::string& TaskResult::_internal_error_msg() const {
  return _impl_.error_msg_.Get();
}
inline void TaskResult::_internal_set_error_msg(const std::string& value) {
  
  _impl_.error_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskResult::_internal_mutable_error_msg() {
  
  return _impl_.error_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* TaskResult::release_error_msg() {
  // @@protoc_insertion_point(field_release:dispatch.TaskResult.error_msg)
  return _impl_.error_msg_.Release();
}
inline void TaskResult::set_allocated_error_msg(std::string* error_msg) {
  if (error_msg != nullptr) {
    
  } else {
    
  }
  _impl_.error_msg_.SetAllocated(error_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_msg_.IsDefault()) {
    _impl_.error_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dispatch.TaskResult.error_msg)
}

// -------------------------------------------------------------------

// EmergencyBrake

// .dispatch.MsgHeader header = 1;
inline bool EmergencyBrake::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool EmergencyBrake::has_header() const {
  return _internal_has_header();
}
inline void EmergencyBrake::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::dispatch::MsgHeader& EmergencyBrake::_internal_header() const {
  const ::dispatch::MsgHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::MsgHeader&>(
      ::dispatch::_MsgHeader_default_instance_);
}
inline const ::dispatch::MsgHeader& EmergencyBrake::header() const {
  // @@protoc_insertion_point(field_get:dispatch.EmergencyBrake.header)
  return _internal_header();
}
inline void EmergencyBrake::unsafe_arena_set_allocated_header(
    ::dispatch::MsgHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.EmergencyBrake.header)
}
inline ::dispatch::MsgHeader* EmergencyBrake::release_header() {
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::MsgHeader* EmergencyBrake::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:dispatch.EmergencyBrake.header)
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::dispatch::MsgHeader* EmergencyBrake::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::MsgHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::dispatch::MsgHeader* EmergencyBrake::mutable_header() {
  ::dispatch::MsgHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:dispatch.EmergencyBrake.header)
  return _msg;
}
inline void EmergencyBrake::set_allocated_header(::dispatch::MsgHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:dispatch.EmergencyBrake.header)
}

// bool valid = 2;
inline void EmergencyBrake::clear_valid() {
  _impl_.valid_ = false;
}
inline bool EmergencyBrake::_internal_valid() const {
  return _impl_.valid_;
}
inline bool EmergencyBrake::valid() const {
  // @@protoc_insertion_point(field_get:dispatch.EmergencyBrake.valid)
  return _internal_valid();
}
inline void EmergencyBrake::_internal_set_valid(bool value) {
  
  _impl_.valid_ = value;
}
inline void EmergencyBrake::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:dispatch.EmergencyBrake.valid)
}

// -------------------------------------------------------------------

// Heartbeat

// .dispatch.MsgHeader header = 1;
inline bool Heartbeat::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool Heartbeat::has_header() const {
  return _internal_has_header();
}
inline void Heartbeat::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::dispatch::MsgHeader& Heartbeat::_internal_header() const {
  const ::dispatch::MsgHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::MsgHeader&>(
      ::dispatch::_MsgHeader_default_instance_);
}
inline const ::dispatch::MsgHeader& Heartbeat::header() const {
  // @@protoc_insertion_point(field_get:dispatch.Heartbeat.header)
  return _internal_header();
}
inline void Heartbeat::unsafe_arena_set_allocated_header(
    ::dispatch::MsgHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.Heartbeat.header)
}
inline ::dispatch::MsgHeader* Heartbeat::release_header() {
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::MsgHeader* Heartbeat::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:dispatch.Heartbeat.header)
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::dispatch::MsgHeader* Heartbeat::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::MsgHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::dispatch::MsgHeader* Heartbeat::mutable_header() {
  ::dispatch::MsgHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:dispatch.Heartbeat.header)
  return _msg;
}
inline void Heartbeat::set_allocated_header(::dispatch::MsgHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:dispatch.Heartbeat.header)
}

// -------------------------------------------------------------------

// HeartbeatACK

// .dispatch.MsgHeader header = 1;
inline bool HeartbeatACK::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool HeartbeatACK::has_header() const {
  return _internal_has_header();
}
inline void HeartbeatACK::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::dispatch::MsgHeader& HeartbeatACK::_internal_header() const {
  const ::dispatch::MsgHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::MsgHeader&>(
      ::dispatch::_MsgHeader_default_instance_);
}
inline const ::dispatch::MsgHeader& HeartbeatACK::header() const {
  // @@protoc_insertion_point(field_get:dispatch.HeartbeatACK.header)
  return _internal_header();
}
inline void HeartbeatACK::unsafe_arena_set_allocated_header(
    ::dispatch::MsgHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.HeartbeatACK.header)
}
inline ::dispatch::MsgHeader* HeartbeatACK::release_header() {
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::MsgHeader* HeartbeatACK::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:dispatch.HeartbeatACK.header)
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::dispatch::MsgHeader* HeartbeatACK::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::MsgHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::dispatch::MsgHeader* HeartbeatACK::mutable_header() {
  ::dispatch::MsgHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:dispatch.HeartbeatACK.header)
  return _msg;
}
inline void HeartbeatACK::set_allocated_header(::dispatch::MsgHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:dispatch.HeartbeatACK.header)
}

// -------------------------------------------------------------------

// FaultInformation

// .dispatch.MsgHeader header = 1;
inline bool FaultInformation::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool FaultInformation::has_header() const {
  return _internal_has_header();
}
inline void FaultInformation::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::dispatch::MsgHeader& FaultInformation::_internal_header() const {
  const ::dispatch::MsgHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::dispatch::MsgHeader&>(
      ::dispatch::_MsgHeader_default_instance_);
}
inline const ::dispatch::MsgHeader& FaultInformation::header() const {
  // @@protoc_insertion_point(field_get:dispatch.FaultInformation.header)
  return _internal_header();
}
inline void FaultInformation::unsafe_arena_set_allocated_header(
    ::dispatch::MsgHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dispatch.FaultInformation.header)
}
inline ::dispatch::MsgHeader* FaultInformation::release_header() {
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dispatch::MsgHeader* FaultInformation::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:dispatch.FaultInformation.header)
  
  ::dispatch::MsgHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::dispatch::MsgHeader* FaultInformation::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::dispatch::MsgHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::dispatch::MsgHeader* FaultInformation::mutable_header() {
  ::dispatch::MsgHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:dispatch.FaultInformation.header)
  return _msg;
}
inline void FaultInformation::set_allocated_header(::dispatch::MsgHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:dispatch.FaultInformation.header)
}

// .dispatch.FaultType type = 2;
inline void FaultInformation::clear_type() {
  _impl_.type_ = 0;
}
inline ::dispatch::FaultType FaultInformation::_internal_type() const {
  return static_cast< ::dispatch::FaultType >(_impl_.type_);
}
inline ::dispatch::FaultType FaultInformation::type() const {
  // @@protoc_insertion_point(field_get:dispatch.FaultInformation.type)
  return _internal_type();
}
inline void FaultInformation::_internal_set_type(::dispatch::FaultType value) {
  
  _impl_.type_ = value;
}
inline void FaultInformation::set_type(::dispatch::FaultType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:dispatch.FaultInformation.type)
}

// uint32 fault_code = 3;
inline void FaultInformation::clear_fault_code() {
  _impl_.fault_code_ = 0u;
}
inline uint32_t FaultInformation::_internal_fault_code() const {
  return _impl_.fault_code_;
}
inline uint32_t FaultInformation::fault_code() const {
  // @@protoc_insertion_point(field_get:dispatch.FaultInformation.fault_code)
  return _internal_fault_code();
}
inline void FaultInformation::_internal_set_fault_code(uint32_t value) {
  
  _impl_.fault_code_ = value;
}
inline void FaultInformation::set_fault_code(uint32_t value) {
  _internal_set_fault_code(value);
  // @@protoc_insertion_point(field_set:dispatch.FaultInformation.fault_code)
}

// string fault_str = 4;
inline void FaultInformation::clear_fault_str() {
  _impl_.fault_str_.ClearToEmpty();
}
inline const std::string& FaultInformation::fault_str() const {
  // @@protoc_insertion_point(field_get:dispatch.FaultInformation.fault_str)
  return _internal_fault_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FaultInformation::set_fault_str(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fault_str_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dispatch.FaultInformation.fault_str)
}
inline std::string* FaultInformation::mutable_fault_str() {
  std::string* _s = _internal_mutable_fault_str();
  // @@protoc_insertion_point(field_mutable:dispatch.FaultInformation.fault_str)
  return _s;
}
inline const std::string& FaultInformation::_internal_fault_str() const {
  return _impl_.fault_str_.Get();
}
inline void FaultInformation::_internal_set_fault_str(const std::string& value) {
  
  _impl_.fault_str_.Set(value, GetArenaForAllocation());
}
inline std::string* FaultInformation::_internal_mutable_fault_str() {
  
  return _impl_.fault_str_.Mutable(GetArenaForAllocation());
}
inline std::string* FaultInformation::release_fault_str() {
  // @@protoc_insertion_point(field_release:dispatch.FaultInformation.fault_str)
  return _impl_.fault_str_.Release();
}
inline void FaultInformation::set_allocated_fault_str(std::string* fault_str) {
  if (fault_str != nullptr) {
    
  } else {
    
  }
  _impl_.fault_str_.SetAllocated(fault_str, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fault_str_.IsDefault()) {
    _impl_.fault_str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dispatch.FaultInformation.fault_str)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dispatch

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MQTT_5fCommunication_2eproto
